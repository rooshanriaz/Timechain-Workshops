/// <reference types="node" />
import { Balance, Token, TokenBalance, TokenUtxo, NftUtxo } from "@sensible-contract/abstract-provider";
import { Utxo, BlockResp, BlockInfoResp, TxDetailResp, InputResp, OutputResp, OutpointResp, XpubDetailResp, XpubBalanceResp, XpubUtxoResp, XpubTxResp, xpubPathResp, NftSellUtxoResp, BroadcastResp } from "./type/type";
import { BaseProvider } from "./base-provider";
export declare type AuthorizationOption = {
    /**
     * should be provided in MetaSV
     */
    authorization?: string;
    /**
     * should be provided in MetaSV
     */
    privateKey?: string;
};
export declare class MetaSVProvider extends BaseProvider {
    apiPrefix: string;
    private authorization;
    private privateKey;
    private publicKey;
    constructor(network: "mainnet" | "testnet", options: AuthorizationOption);
    authorize(options: AuthorizationOption): void;
    private _getHeaders;
    getBlockInfo(): Promise<BlockInfoResp>;
    getBlock(last: number): Promise<BlockResp>;
    getBlockWithBlockId(blockId: string): Promise<BlockResp>;
    getTxidDetail(txid: string, showScript?: boolean): Promise<{
        txDetail: TxDetailResp;
        inputs: InputResp[];
        outputs: OutputResp[];
    }>;
    getSeenTx(txid: string): Promise<boolean>;
    getVinOutpointDetail(txid: string): Promise<OutpointResp>;
    getOutpoint(txid: string, index: number): Promise<OutpointResp>;
    aBroadcast(hex: string): Promise<string>;
    aBroadcastState(txid: string): Promise<BroadcastResp>;
    mBroadcast(hex: string): Promise<string>;
    getXpubs(flag?: string): Promise<string[]>;
    getXpubsCount(): Promise<string>;
    registXpub(xpub: string, skipHeight?: number, initReceiveIndex?: number, initChangeIndex?: number): Promise<string>;
    getXpub(xpub: string): Promise<XpubDetailResp>;
    deleteXpub(xpub: string): Promise<string>;
    getXpubBalance(xpub: string | Buffer): Promise<XpubBalanceResp>;
    getXpubUtxo(xpub: string, limit?: number): Promise<XpubUtxoResp[]>;
    getXpubUtxoCount(xpub: string): Promise<number>;
    getXpubTxs(xpub: string, flag?: string): Promise<XpubTxResp[]>;
    getXpubPath(xpub: string, address: string): Promise<xpubPathResp>;
    getXpubliteUtxo(xpub: string, limit?: number): Promise<XpubUtxoResp>;
    getXpublitePath(xpub: string, address: string): Promise<xpubPathResp>;
    getXpubliteBalance(xpub: string): Promise<XpubBalanceResp>;
    getUtxos(address: string, queryParams?: any): Promise<Utxo[]>;
    getRawTx(txid: string): Promise<string>;
    broadcast(rawtx: string): Promise<string>;
    getBalance(address: string): Promise<Balance>;
    getIsUtxoSpent(txId: string, outputIndex: number): Promise<boolean>;
    getTokenUtxos(codehash: string, genesis: string, address: string, queryParams?: any): Promise<TokenUtxo[]>;
    getTokenBalance(codehash: string, genesis: string, address: string): Promise<TokenBalance>;
    getTokenList(address: string, queryParams?: {
        cursor: number;
        size: number;
    }): Promise<Token[]>;
    getNftUtxos(codehash: string, genesis: string, address: string, queryParams?: {
        cursor: number;
        size: number;
    }): Promise<NftUtxo[]>;
    getNftUtxo(codehash: string, genesis: string, tokenIndex: string): Promise<NftUtxo>;
    getNftAuctionUtxo(codehash: string, nftid: string): Promise<{
        txId: any;
        outputIndex: any;
    }>;
    getNftSellUtxo(codehash: string, genesis: string, tokenIndex: string): Promise<{
        txId: string;
        outputIndex: string;
        sellerAddress: string;
        satoshisPrice: number;
    }>;
    getNftAddressSellUtxo(address: string, codeHash?: string, genesis?: string, flag?: string): Promise<NftSellUtxoResp[]>;
}
