"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftGenesisFactory = exports.NftGenesis = void 0;
const BN = require("../../bn.js");
const bsv = require("../../bsv");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const protoheader_1 = require("../../common/protoheader");
const utils_1 = require("../../common/utils");
const scryptlib_1 = require("../../scryptlib");
const nftProto = require("../contract-proto/nft.proto");
const nft_1 = require("./nft");
const genesisTokenIDTxid = "0000000000000000000000000000000000000000000000000000000000000000";
class NftGenesis extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        const desc = require("../contract-desc/nftGenesis_desc.json");
        let GenesisContractClass = (0, scryptlib_1.buildContractClass)(desc);
        let contract = new GenesisContractClass(new scryptlib_1.PubKey((0, scryptlib_1.toHex)(constuctParams.issuerPubKey)));
        super(contract);
        this.constuctParams = constuctParams;
    }
    clone() {
        let contract = new NftGenesis(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        this._formatedDataPart.genesisHash = "";
        this._formatedDataPart.genesisFlag = nftProto.GENESIS_FLAG.TRUE;
        this._formatedDataPart.protoVersion = nftProto.PROTO_VERSION;
        this._formatedDataPart.protoType = protoheader_1.PROTO_TYPE.NFT;
        super.setDataPart((0, scryptlib_1.toHex)(nftProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    setFormatedDataPartFromLockingScript(script) {
        let dataPart = nftProto.parseDataPart(script.toBuffer());
        this.setFormatedDataPart(dataPart);
    }
    isFirstGenesis() {
        return this.getFormatedDataPart().sensibleID.txid == genesisTokenIDTxid;
    }
    unlock({ txPreimage, sig, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, genesisSatoshis, nftScript, nftSatoshis, changeAddress, changeSatoshis, opReturnScript, }) {
        return this._contract.unlock(txPreimage, sig, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, genesisSatoshis, nftScript, nftSatoshis, changeAddress, changeSatoshis, opReturnScript);
    }
}
exports.NftGenesis = NftGenesis;
class NftGenesisFactory {
    static getLockingScriptSize() {
        return this.lockingScriptSize;
    }
    static createContract(issuerPubKey) {
        return new NftGenesis({ issuerPubKey });
    }
    static getDummyInstance() {
        let contract = this.createContract(dummy_1.dummyPk);
        contract.setFormatedDataPart({});
        return contract;
    }
    static calLockingScriptSize() {
        let contract = this.getDummyInstance();
        let size = contract.lockingScript.toBuffer().length;
        return size;
    }
    static calUnlockingScriptSize(opreturnData) {
        let opreturnScriptHex = "";
        if (opreturnData) {
            let script = bsv.Script.buildSafeDataOut(opreturnData);
            opreturnScriptHex = script.toHex();
        }
        let contract = this.getDummyInstance();
        let tokenContract = nft_1.NftFactory.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const sig = Buffer.from(utils_1.PLACE_HOLDER_SIG, "hex");
        const rabinMsg = dummy_1.dummyPayload;
        const rabinPaddingArray = [];
        const rabinSigArray = [];
        const rabinPubKeyIndexArray = [];
        const rabinPubKeyArray = [];
        for (let i = 0; i < nftProto.SIGNER_VERIFY_NUM; i++) {
            rabinPaddingArray.push(new scryptlib_1.Bytes(dummy_1.dummyPadding));
            rabinSigArray.push(new scryptlib_1.Int(BN.fromString(dummy_1.dummySigBE, 16).toString(10)));
            rabinPubKeyIndexArray.push(i);
            rabinPubKeyArray.push(new scryptlib_1.Int(dummy_1.dummyRabinPubKey.toString(10)));
        }
        let unlockResult = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            sig: new scryptlib_1.Sig((0, scryptlib_1.toHex)(sig)),
            rabinMsg: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(rabinMsg)),
            rabinPaddingArray,
            rabinSigArray,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray: rabinPubKeyArray,
            rabinPubKeyHashArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyRabinPubKeyHashArray)),
            genesisSatoshis: 1000,
            nftScript: new scryptlib_1.Bytes(tokenContract.lockingScript.toHex()),
            nftSatoshis: 1000,
            changeAddress: new scryptlib_1.Ripemd160((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            changeSatoshis: 1000,
            opReturnScript: new scryptlib_1.Bytes(opreturnScriptHex),
        });
        return unlockResult.toScript().toBuffer().length;
    }
}
exports.NftGenesisFactory = NftGenesisFactory;
