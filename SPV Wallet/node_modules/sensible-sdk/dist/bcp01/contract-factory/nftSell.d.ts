import * as bsv from "../../bsv";
import { ContractAdapter } from "../../common/ContractAdapter";
import { Bytes, FunctionCall, PubKey, Ripemd160, Sig, SigHashPreimage } from "../../scryptlib";
import * as nftSellProto from "../contract-proto/nftSell.proto";
export declare enum NFT_SELL_OP {
    SELL = 1,
    CANCEL = 2
}
export declare class NftSell extends ContractAdapter {
    private _formatedDataPart;
    constuctParams: {
        senderAddress: Ripemd160;
        bsvRecAmount: number;
        nftCodeHash: Bytes;
        nftID: Bytes;
    };
    static getClass(): any;
    constructor(constuctParams: {
        senderAddress: Ripemd160;
        bsvRecAmount: number;
        nftCodeHash: Bytes;
        nftID: Bytes;
    });
    static fromASM(asm: string): NftSell;
    clone(): NftSell;
    setFormatedDataPart(dataPart: nftSellProto.FormatedDataPart): void;
    getFormatedDataPart(): nftSellProto.FormatedDataPart;
    setFormatedDataPartFromLockingScript(script: bsv.Script): void;
    unlock({ txPreimage, nftScript, // only cancel need
    senderPubKey, // only cancel need
    senderSig, // only cancel need
    nftOutputSatoshis, // only cancel need
    op, }: {
        txPreimage: SigHashPreimage;
        nftScript?: Bytes;
        senderPubKey?: PubKey;
        senderSig?: Sig;
        nftOutputSatoshis?: number;
        op: NFT_SELL_OP;
    }): FunctionCall;
}
export declare class NftSellFactory {
    static lockingScriptSize: number;
    static getLockingScriptSize(): number;
    static createContract(senderAddress: Ripemd160, bsvRecAmount: number, nftCodeHash: Bytes, nftID: Bytes): NftSell;
    static createFromASM(asm: string): NftSell;
    static getDummyInstance(): NftSell;
    static calLockingScriptSize(): number;
    static calUnlockingScriptSize(op: NFT_SELL_OP): number;
}
