"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftSellFactory = exports.NftSell = exports.NFT_SELL_OP = void 0;
const bn_js_1 = require("../../bn.js");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const protoheader_1 = require("../../common/protoheader");
const utils_1 = require("../../common/utils");
const scryptlib_1 = require("../../scryptlib");
const nftSellProto = require("../contract-proto/nftSell.proto");
const nft_1 = require("./nft");
var NFT_SELL_OP;
(function (NFT_SELL_OP) {
    NFT_SELL_OP[NFT_SELL_OP["SELL"] = 1] = "SELL";
    NFT_SELL_OP[NFT_SELL_OP["CANCEL"] = 2] = "CANCEL";
})(NFT_SELL_OP = exports.NFT_SELL_OP || (exports.NFT_SELL_OP = {}));
class NftSell extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let NftSellContractClass = NftSell.getClass();
        let contract = new NftSellContractClass(constuctParams.senderAddress, constuctParams.bsvRecAmount, constuctParams.nftCodeHash, constuctParams.nftID);
        super(contract);
        this.constuctParams = constuctParams;
    }
    static getClass() {
        const desc = require("../contract-desc/nftSell_desc.json");
        let NftSellContractClass = (0, scryptlib_1.buildContractClass)(desc);
        return NftSellContractClass;
    }
    static fromASM(asm) {
        let NftSellContractClass = NftSell.getClass();
        let contract = NftSellContractClass.fromASM(asm);
        let params = contract.scriptedConstructor.params;
        let senderAddress = params[0];
        let bsvRecAmount = parseInt(params[1].value);
        let nftCodeHash = params[2];
        let nftID = params[3];
        return new NftSell({ senderAddress, bsvRecAmount, nftCodeHash, nftID });
    }
    clone() {
        let contract = new NftSell(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        this._formatedDataPart.protoVersion = nftSellProto.PROTO_VERSION;
        this._formatedDataPart.protoType = protoheader_1.PROTO_TYPE.NFT_SELL;
        super.setDataPart((0, scryptlib_1.toHex)(nftSellProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    setFormatedDataPartFromLockingScript(script) {
        let dataPart = nftSellProto.parseDataPart(script.toBuffer());
        this.setFormatedDataPart(dataPart);
    }
    unlock({ txPreimage, nftScript, // only cancel need
    senderPubKey, // only cancel need
    senderSig, // only cancel need
    nftOutputSatoshis, // only cancel need
    op, }) {
        if (op != NFT_SELL_OP.CANCEL) {
            nftScript = new scryptlib_1.Bytes("");
            senderPubKey = new scryptlib_1.PubKey("00");
            senderSig = new scryptlib_1.Sig("00");
            nftOutputSatoshis = 0;
        }
        return this._contract.unlock(txPreimage, nftScript, senderPubKey, senderSig, nftOutputSatoshis, op);
    }
}
exports.NftSell = NftSell;
class NftSellFactory {
    static getLockingScriptSize() {
        return this.lockingScriptSize;
    }
    static createContract(senderAddress, bsvRecAmount, nftCodeHash, nftID) {
        return new NftSell({ senderAddress, bsvRecAmount, nftCodeHash, nftID });
    }
    static createFromASM(asm) {
        return NftSell.fromASM(asm);
    }
    static getDummyInstance() {
        let contract = this.createContract(new scryptlib_1.Ripemd160((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)), 1000, new scryptlib_1.Bytes((0, scryptlib_1.toHex)(Buffer.alloc(20, 0))), new scryptlib_1.Bytes((0, scryptlib_1.toHex)(Buffer.alloc(36, 0))));
        return contract;
    }
    static calLockingScriptSize() {
        let contract = this.getDummyInstance();
        contract.setFormatedDataPart({
            codehash: (0, scryptlib_1.toHex)(dummy_1.dummyCodehash),
            genesis: (0, scryptlib_1.toHex)(dummy_1.dummyCodehash),
            tokenIndex: bn_js_1.BN.fromString("10000000000", 10),
            sellerAddress: (0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer),
            satoshisPrice: bn_js_1.BN.fromString("100000000", 10),
            nftID: (0, scryptlib_1.toHex)(dummy_1.dummyCodehash),
        });
        let size = contract.lockingScript.toBuffer().length;
        return size;
    }
    static calUnlockingScriptSize(op) {
        let contract = this.getDummyInstance();
        let nftContract = nft_1.NftFactory.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const sig = Buffer.from(utils_1.PLACE_HOLDER_SIG, "hex");
        let unlockResult = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            nftScript: new scryptlib_1.Bytes(nftContract.lockingScript.toHex()),
            senderPubKey: new scryptlib_1.PubKey((0, scryptlib_1.toHex)(dummy_1.dummyPk)),
            senderSig: new scryptlib_1.Sig((0, scryptlib_1.toHex)(sig)),
            nftOutputSatoshis: 1000,
            op,
        });
        return unlockResult.toScript().toBuffer().length;
    }
}
exports.NftSellFactory = NftSellFactory;
