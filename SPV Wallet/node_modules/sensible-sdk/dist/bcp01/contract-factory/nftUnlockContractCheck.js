"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftUnlockContractCheckFactory = exports.NFT_UNLOCK_CONTRACT_TYPE = exports.NftUnlockContractCheck = void 0;
const BN = require("../../bn.js");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const scryptlib_1 = require("../../scryptlib");
const nft_proto_1 = require("../contract-proto/nft.proto");
const unlockProto = require("../contract-proto/nftUnlockContractCheck.proto");
const nft_1 = require("./nft");
class NftUnlockContractCheck extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let desc;
        switch (constuctParams.unlockType) {
            case NFT_UNLOCK_CONTRACT_TYPE.OUT_3:
                desc = require("../contract-desc/nftUnlockContractCheck_desc.json");
                break;
            case NFT_UNLOCK_CONTRACT_TYPE.OUT_6:
                desc = require("../contract-desc/nftUnlockContractCheck_6_desc.json");
                break;
            case NFT_UNLOCK_CONTRACT_TYPE.OUT_10:
                desc = require("../contract-desc/nftUnlockContractCheck_10_desc.json");
                break;
            case NFT_UNLOCK_CONTRACT_TYPE.OUT_20:
                desc = require("../contract-desc/nftUnlockContractCheck_20_desc.json");
                break;
            case NFT_UNLOCK_CONTRACT_TYPE.OUT_100:
                desc = require("../contract-desc/nftUnlockContractCheck_100_desc.json");
                break;
            default:
                throw "invalid checkType";
        }
        const NftUnlockContractCheckClass = (0, scryptlib_1.buildContractClass)(desc);
        const unlockCheckContract = new NftUnlockContractCheckClass();
        super(unlockCheckContract);
        this.constuctParams = constuctParams;
    }
    clone() {
        let contract = new NftUnlockContractCheck(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        super.setDataPart((0, scryptlib_1.toHex)(unlockProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    unlock({ txPreimage, nftInputIndex, nftScript, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, nOutputs, nftOutputIndex, nftOutputAddress, nftOutputSatoshis, otherOutputArray, }) {
        return this._contract.unlock(txPreimage, nftInputIndex, nftScript, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, nOutputs, nftOutputIndex, nftOutputAddress, nftOutputSatoshis, otherOutputArray);
    }
}
exports.NftUnlockContractCheck = NftUnlockContractCheck;
var NFT_UNLOCK_CONTRACT_TYPE;
(function (NFT_UNLOCK_CONTRACT_TYPE) {
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["OUT_3"] = 1] = "OUT_3";
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["OUT_6"] = 2] = "OUT_6";
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["OUT_10"] = 3] = "OUT_10";
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["OUT_20"] = 4] = "OUT_20";
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["OUT_100"] = 5] = "OUT_100";
    NFT_UNLOCK_CONTRACT_TYPE[NFT_UNLOCK_CONTRACT_TYPE["UNSUPPORT"] = 6] = "UNSUPPORT";
})(NFT_UNLOCK_CONTRACT_TYPE = exports.NFT_UNLOCK_CONTRACT_TYPE || (exports.NFT_UNLOCK_CONTRACT_TYPE = {}));
let _unlockContractTypeInfos = [
    {
        type: NFT_UNLOCK_CONTRACT_TYPE.OUT_3,
        out: 3,
        lockingScriptSize: 0,
    },
    {
        type: NFT_UNLOCK_CONTRACT_TYPE.OUT_6,
        out: 6,
        lockingScriptSize: 0,
    },
    {
        type: NFT_UNLOCK_CONTRACT_TYPE.OUT_10,
        out: 10,
        lockingScriptSize: 0,
    },
    {
        type: NFT_UNLOCK_CONTRACT_TYPE.OUT_20,
        out: 20,
        lockingScriptSize: 0,
    },
    {
        type: NFT_UNLOCK_CONTRACT_TYPE.OUT_100,
        out: 100,
        lockingScriptSize: 0,
    },
];
class NftUnlockContractCheckFactory {
    static getLockingScriptSize(unlockType) {
        return this.unlockContractTypeInfos.find((v) => v.type == unlockType)
            .lockingScriptSize;
    }
    static getOptimumType(outCount) {
        if (outCount <= 3) {
            return NFT_UNLOCK_CONTRACT_TYPE.OUT_3;
        }
        else if (outCount <= 6) {
            return NFT_UNLOCK_CONTRACT_TYPE.OUT_6;
        }
        else if (outCount <= 10) {
            return NFT_UNLOCK_CONTRACT_TYPE.OUT_10;
        }
        else if (outCount <= 20) {
            return NFT_UNLOCK_CONTRACT_TYPE.OUT_20;
        }
        else if (outCount <= 100) {
            return NFT_UNLOCK_CONTRACT_TYPE.OUT_100;
        }
        else {
            return NFT_UNLOCK_CONTRACT_TYPE.UNSUPPORT;
        }
    }
    static createContract(unlockType) {
        return new NftUnlockContractCheck({ unlockType });
    }
    static getDummyInstance(unlockType) {
        let contract = this.createContract(unlockType);
        contract.setFormatedDataPart({
            nftID: dummy_1.dummyCodehash.toBuffer(),
            nftCodeHash: Buffer.from("0000000000000000000000000000000000000000", "hex"),
        });
        return contract;
    }
    static calLockingScriptSize(unlockType) {
        let contract = this.getDummyInstance(unlockType);
        return contract.lockingScript.toBuffer().length;
    }
    static calUnlockingScriptSize(unlockType, prevouts, otherOutputArray) {
        let contract = this.getDummyInstance(unlockType);
        let nftContractInstance = nft_1.NftFactory.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const rabinMsg = new scryptlib_1.Bytes(dummy_1.dummyPayload);
        let paddingCountBuf = Buffer.alloc(2, 0);
        paddingCountBuf.writeUInt16LE(dummy_1.dummyPadding.length / 2);
        const padding = Buffer.alloc(dummy_1.dummyPadding.length / 2, 0);
        padding.write(dummy_1.dummyPadding, "hex");
        const rabinPaddingArray = [];
        const rabinSigArray = [];
        const rabinPubKeyIndexArray = [];
        const rabinPubKeyArray = [];
        let tokenAmount = Buffer.alloc(8);
        tokenAmount.writeInt32BE(100000);
        for (let i = 0; i < nft_proto_1.SIGNER_VERIFY_NUM; i++) {
            rabinPaddingArray.push(new scryptlib_1.Bytes(dummy_1.dummyPadding));
            rabinSigArray.push(new scryptlib_1.Int(BN.fromString(dummy_1.dummySigBE, 16).toString(10)));
            rabinPubKeyIndexArray.push(i);
            rabinPubKeyArray.push(new scryptlib_1.Int(dummy_1.dummyRabinPubKey.toString(10)));
        }
        let unlockedContract = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            nftInputIndex: 0,
            nftScript: new scryptlib_1.Bytes(nftContractInstance.lockingScript.toHex()),
            prevouts: prevouts,
            rabinMsg: rabinMsg,
            rabinPaddingArray: rabinPaddingArray,
            rabinSigArray: rabinSigArray,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray: rabinPubKeyArray,
            rabinPubKeyHashArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyRabinPubKeyHashArray)),
            nOutputs: 2,
            nftOutputIndex: 0,
            nftOutputAddress: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            nftOutputSatoshis: 1000,
            otherOutputArray,
        });
        return unlockedContract.toScript().toBuffer().length;
    }
}
exports.NftUnlockContractCheckFactory = NftUnlockContractCheckFactory;
NftUnlockContractCheckFactory.unlockContractTypeInfos = _unlockContractTypeInfos;
