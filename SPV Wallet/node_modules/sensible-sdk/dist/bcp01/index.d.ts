/// <reference types="node" />
import { Bytes, Int } from "scryptlib";
import * as BN from "../bn.js";
import * as bsv from "../bsv";
import { SatotxSigner, SignerConfig } from "../common/SatotxSigner";
import { SigHashInfo, SigInfo } from "../common/utils";
import { API_NET, API_TARGET, NonFungibleTokenUnspent, SensibleApiBase } from "../sensible-api";
import * as nftProto from "./contract-proto/nft.proto";
export declare const sighashType: number;
declare type SellUtxo = {
    txId: string;
    outputIndex: number;
    sellerAddress: string;
    satoshisPrice: number;
};
export declare class Prevouts {
    _buf: Buffer;
    constructor();
    addVout(txId: string, outputIndex: number): void;
    toHex(): string;
}
export declare type Utxo = {
    txId: string;
    outputIndex: number;
    satoshis: number;
    address: bsv.Address;
};
export declare type NftUtxo = {
    txId: string;
    outputIndex: number;
    satoshis?: number;
    lockingScript?: bsv.Script;
    satotxInfo?: {
        txId: string;
        outputIndex: number;
        txHex: string;
        preTxId: string;
        preOutputIndex: number;
        preTxHex: string;
    };
    nftAddress?: bsv.Address;
    preNftAddress?: bsv.Address;
    preLockingScript?: bsv.Script;
    publicKey?: bsv.PublicKey;
    inputIndex?: number;
};
export declare type RabinUtxo = {
    txId: string;
    outputIndex: number;
    txHex: string;
    preTxId: string;
    preOutputIndex: number;
    preTxHex: string;
};
export declare type ParamUtxo = {
    txId: string;
    outputIndex: number;
    satoshis: number;
    wif?: string;
    address?: any;
};
export declare const defaultSignerConfigs: SignerConfig[];
declare type MockData = {
    sensibleApi: SensibleApiBase;
    satotxSigners: SatotxSigner[];
};
/**
Sensible Non Fungible Token
 */
export declare class SensibleNFT {
    private signers;
    private feeb;
    private network;
    private purse;
    sensibleApi: SensibleApiBase;
    private zeroAddress;
    private debug;
    private signerSelecteds;
    private dustCalculator;
    rabinPubKeyArray: Int[];
    rabinPubKeyHashArray: Bytes;
    rabinPubKeyHashArrayHash: Buffer;
    unlockContractCodeHashArray: Bytes[];
    /**
     *
     * @param signers
     * @param signerSelecteds (Optional) the indexs of the signers which is decided to verify
     * @param feeb (Optional) the fee rate. default is 0.5
     * @param network (Optional) mainnet/testnet default is mainnet
     * @param purse (Optional) the private key to offer transacions fee. If not provided, bsv utoxs must be provided in genesis/issue/transfer.
     * @param debug (Optional) specify if verify the tx when genesis/issue/transfer, default is false
     * @param apiTarget (Optional) SENSIBLE/METASV, default is SENSIBLE.
     * @param dustLimitFactor (Optional) specify the output dust rate, default is 0.25 .If the value is equal to 0, the final dust will be at least 1.
     * @param dustAmount (Optional) specify the output dust.
     */
    constructor({ signers, signerSelecteds, feeb, network, purse, debug, apiTarget, apiUrl, mockData, dustLimitFactor, dustAmount, }: {
        signers?: SignerConfig[];
        signerSelecteds?: number[];
        feeb?: number;
        network?: API_NET;
        purse?: string;
        debug?: boolean;
        apiTarget?: API_TARGET;
        apiUrl?: string;
        mockData?: MockData;
        dustLimitFactor?: number;
        dustAmount?: number;
    });
    /**
     * Pick the signer with the best connectivity
     * @param signerConfigs
     * @returns
     */
    static selectSigners(signerConfigs?: SignerConfig[]): Promise<{
        signers: SignerConfig[];
        signerSelecteds: number[];
    }>;
    /**
     * set dust. DustAmount has a higher priority than dustLimitFactor
     * @param dustLimitFactor specify the output dust rate, default is 0.25 .If the value is equal to 0, the final dust will be at least 1.
     * @param dustAmount specify the output dust
     */
    setDustThreshold({ dustLimitFactor, dustAmount, }: {
        dustLimitFactor?: number;
        dustAmount?: number;
    }): void;
    private getDustThreshold;
    private _pretreatUtxos;
    private _pretreatNftUtxoToTransfer;
    private _pretreatNftUtxoToIssue;
    private _pretreatNftUtxoToTransferOn;
    /**
     * Create a transaction for genesis
     * @param genesisWif the private key of the token genesiser
     * @param totalSupply total supply, 8 bytes unsign int
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    genesis({ genesisWif, totalSupply, opreturnData, utxos, changeAddress, noBroadcast, }: {
        genesisWif: string | bsv.PrivateKey;
        totalSupply: string | BN;
        opreturnData?: string | Buffer | any[];
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
    }): Promise<{
        codehash: string;
        genesis: string;
        sensibleId: string;
        txid: string;
        txHex: string;
        tx: bsv.Transaction;
    }>;
    /**
     * create an unsigned transaction for genesis
     * @param genesisPublicKey the public key of the token genesiser
     * @param totalSupply total supply, 8 bytes unsign int
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @returns
     */
    unsignGenesis({ genesisPublicKey, totalSupply, opreturnData, utxos, changeAddress, }: {
        genesisPublicKey: string | bsv.PublicKey;
        totalSupply: string | BN;
        opreturnData?: any;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
    }): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    private _genesis;
    /**
     * Mint a NFT
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param sensibleId the sensibleId of NFT.
     * @param genesisWif the private key of the NFT genesiser
     * @param receiverAddress the NFT receiver address
     * @param metaTxId  the txid of meta info outpoint.To describe NFT status, metaId is recommended
     * @param metaOutputIndex the index of meta info outpoint.
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    issue({ genesis, codehash, sensibleId, genesisWif, receiverAddress, metaTxId, metaOutputIndex, opreturnData, utxos, changeAddress, noBroadcast, }: {
        genesis: string;
        codehash: string;
        sensibleId: string;
        genesisWif: string;
        receiverAddress: string | bsv.Address;
        metaTxId?: string;
        metaOutputIndex?: number;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
    }): Promise<{
        txHex: string;
        txid: string;
        tx: bsv.Transaction;
        tokenIndex: string;
    }>;
    /**
     * Create the unsigned transaction for issue NFT,
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param genesisPublicKey the public key of the NFT genesiser
     * @param receiverAddress the NFT receiver address
     * @param metaTxId  the txid of meta info outpoint.To describe NFT status, metaId is recommended
     * @param metaOutputIndex the index of meta info outpoint..
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @returns
     */
    unsignIssue({ genesis, codehash, sensibleId, genesisPublicKey, receiverAddress, metaTxId, metaOutputIndex, opreturnData, utxos, changeAddress, }: {
        genesis: string;
        codehash: string;
        sensibleId: string;
        genesisPublicKey: string | bsv.PublicKey;
        receiverAddress: string | bsv.Address;
        metaTxId?: string;
        metaOutputIndex?: number;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
    }): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
        tokenIndex: string;
    }>;
    private getIssueUtxo;
    prepareNftUtxo2(nftUtxo: NftUtxo): Promise<void>;
    private _issue;
    /**
     * Create a transaction and broadcast it to transfer a NFT.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param senderWif the private key of the token sender,can be wif or other format
     * @param senderPrivateKey the private key of the token sender
     * @param receiverAddress  the NFT receiver address
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    transfer({ genesis, codehash, tokenIndex, senderWif, senderPrivateKey, receiverAddress, opreturnData, utxos, changeAddress, noBroadcast, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        senderWif?: string;
        senderPrivateKey?: string | bsv.PrivateKey;
        receiverAddress: string | bsv.Address;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
    }): Promise<{
        tx: bsv.Transaction;
        txid: string;
        txHex: string;
    }>;
    /**
     * Create an unsigned transaction to transfer a NFT.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param senderPublicKey the public key of the NFT sender
     * @param receiverAddress  the NFT receiver address
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @returns
     */
    unsignTransfer({ genesis, codehash, tokenIndex, senderPublicKey, receiverAddress, opreturnData, utxos, changeAddress, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        senderPublicKey: string | bsv.PublicKey;
        receiverAddress: string | bsv.Address;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
    }): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    private _transfer;
    /**
     * Create a transaction and broadcast it to sell a NFT.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param sellerPrivateKey the private key of the token seller
     * @param satoshisPrice  the satoshis price to sell.
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @param middleChangeAddress (Optional) the middle bsv changeAddress
     * @param middlePrivateKey (Optional) the private key of the middle changeAddress
     * @returns
     */
    sell({ genesis, codehash, tokenIndex, sellerWif, sellerPrivateKey, satoshisPrice, opreturnData, utxos, changeAddress, noBroadcast, middleChangeAddress, middlePrivateKey, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        sellerWif?: string;
        sellerPrivateKey?: string | bsv.PrivateKey;
        satoshisPrice: number;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
        middleChangeAddress?: string | bsv.Address;
        middlePrivateKey?: string | bsv.PrivateKey;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        sellTxId: string;
        sellTx: bsv.Transaction;
        sellTxHex: string;
    }>;
    private _sell;
    /**
     * Create a sellUtxo transaction.To sell a NFT you should transfer it to this sellAddress.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param sellerPrivateKey the private key of the token seller
     * @param satoshisPrice  the satoshis price to sell.
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    sell2({ genesis, codehash, tokenIndex, sellerWif, sellerPrivateKey, satoshisPrice, opreturnData, utxos, changeAddress, noBroadcast, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        sellerWif?: string;
        sellerPrivateKey?: string | bsv.PrivateKey;
        satoshisPrice: number;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        sellAddress: string;
    }>;
    private _sell2;
    /**
     * Create a transaction and broadcast it to put off a NFT.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param sellerPrivateKey the private key of the token seller
     * @param satoshisPrice  the satoshis price to sell.
     * @param sellUtxo (Optional) sometimes you may need to specify the sellUtxo
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @param middleChangeAddress (Optional) the middle bsv changeAddress
     * @param middlePrivateKey (Optional) the private key of the middle changeAddress
     * @returns
     */
    cancelSell({ genesis, codehash, tokenIndex, sellerWif, sellerPrivateKey, sellUtxo, opreturnData, utxos, changeAddress, noBroadcast, middleChangeAddress, middlePrivateKey, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        sellerWif?: string | bsv.PrivateKey;
        sellerPrivateKey?: string | bsv.PrivateKey;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
        sellUtxo?: SellUtxo;
        middleChangeAddress?: string | bsv.Address;
        middlePrivateKey?: string | bsv.PrivateKey;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        unlockCheckTxId: string;
        unlockCheckTx: bsv.Transaction;
        unlockCheckTxHex: string;
    }>;
    private _cancelSell;
    /**
     * Create a transaction and broadcast it to buy a NFT.
     * @param genesis the genesis of NFT.
     * @param codehash the codehash of NFT.
     * @param tokenIndex the tokenIndex of NFT.
     * @param buyerPrivateKey the private key of the token buyer
     * @param sellUtxo (Optional) sometimes you may need to specify the sellUtxo
     * @param opreturnData (Optional) append an opReturn output
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @param middleChangeAddress (Optional) the middle bsv changeAddress
     * @param middlePrivateKey (Optional) the private key of the middle changeAddress
     * @returns
     */
    buy({ genesis, codehash, tokenIndex, buyerWif, buyerPrivateKey, sellUtxo, opreturnData, utxos, changeAddress, noBroadcast, middleChangeAddress, middlePrivateKey, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        buyerWif?: string;
        buyerPrivateKey?: string | bsv.PrivateKey;
        sellUtxo?: SellUtxo;
        opreturnData?: any;
        utxos?: any[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
        middleChangeAddress?: string | bsv.Address;
        middlePrivateKey?: string | bsv.PrivateKey;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        unlockCheckTxId: string;
        unlockCheckTx: bsv.Transaction;
        unlockCheckTxHex: string;
    }>;
    private _buy;
    /**
     * Query the NFT list under this address.
     * @param address
     * @returns
     */
    getSummary(address: string): Promise<import("../sensible-api").NonFungibleTokenSummary[]>;
    /**
     * Query a kind of NFT tokens held by address.
     * @param codehash the codehash of NFT
     * @param genesis the genesis of NFT
     * @param address owner address
     * @returns
     */
    getSummaryDetail(codehash: string, genesis: string, address: string, cursor?: number, size?: number): Promise<NonFungibleTokenUnspent[]>;
    /**
     * Estimate the cost of genesis
     * The minimum cost required in the case of 10 utxo inputs
     * @param opreturnData
     * @param utxoMaxCount Maximum number of BSV UTXOs supported
     * @returns
     */
    getGenesisEstimateFee({ opreturnData, utxoMaxCount, }: {
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    /**
     * Estimate the cost of issue
     * The minimum cost required in the case of 10 utxo inputs .
     * @param sensibleId
     * @param genesisPublicKey
     * @param opreturnData
     * @param utxoMaxCount Maximum number of BSV UTXOs supported
     * @returns
     */
    getIssueEstimateFee({ sensibleId, genesisPublicKey, opreturnData, utxoMaxCount, }: {
        sensibleId: string;
        genesisPublicKey: string | bsv.PublicKey;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    private _calIssueEstimateFee;
    private _calTransferEstimateFee;
    /**
     * Estimate the cost of transfer
     * senderPrivateKey and senderPublicKey only need to provide one of them
     */
    getTransferEstimateFee({ genesis, codehash, tokenIndex, senderWif, senderPrivateKey, senderPublicKey, opreturnData, utxoMaxCount, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        senderWif?: string;
        senderPrivateKey?: string | bsv.PrivateKey;
        senderPublicKey?: string | bsv.PublicKey;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    private _calSellEstimateFee;
    getSellEstimateFee({ genesis, codehash, tokenIndex, senderWif, senderPrivateKey, senderPublicKey, opreturnData, utxoMaxCount, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        senderWif?: string;
        senderPrivateKey?: string | bsv.PrivateKey;
        senderPublicKey?: string | bsv.PublicKey;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    getSell2EstimateFee({ genesis, codehash, opreturnData, utxoMaxCount, }: {
        genesis: string;
        codehash: string;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    private _calCancelSellEstimateFee;
    /**
     * Estimate the cost of cancel sell
     * senderPrivateKey and senderPublicKey only need to provide one of them
     */
    getCancelSellEstimateFee({ genesis, codehash, tokenIndex, sellerWif, sellerPrivateKey, sellerPublicKey, sellUtxo, opreturnData, utxoMaxCount, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        sellerWif?: string;
        sellerPrivateKey?: string | bsv.PrivateKey;
        sellerPublicKey?: string | bsv.PublicKey;
        sellUtxo?: SellUtxo;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    private _calBuyEstimateFee;
    /**
     * Estimate the cost of buy
     * buyerPrivateKey and buyerPublicKey only need to provide one of them
     */
    getBuyEstimateFee({ genesis, codehash, tokenIndex, buyerWif, buyerPrivateKey, buyerPublicKey, sellUtxo, opreturnData, utxoMaxCount, }: {
        genesis: string;
        codehash: string;
        tokenIndex: string;
        buyerWif?: string;
        buyerPrivateKey?: string | bsv.PrivateKey;
        buyerPublicKey?: string | bsv.PublicKey;
        sellUtxo?: SellUtxo;
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    /**
     * Update the signature of the transaction
     * @param tx
     * @param sigHashList
     * @param sigList
     */
    sign(tx: bsv.Transaction, sigHashList: SigHashInfo[], sigList: SigInfo[]): void;
    /**
     * Broadcast a transaction
     * @param txHex
     */
    broadcast(txHex: string): Promise<string>;
    /**
     * Print tx
     * @param tx
     */
    dumpTx(tx: bsv.Transaction): void;
    private _checkTxFeeRate;
    /**
     * Get codehash and genesis from genesis tx.
     * @param genesisTx genesis tx
     * @param genesisOutputIndex (Optional) outputIndex - default value is 0.
     * @returns
     */
    getCodehashAndGensisByTx(genesisTx: bsv.Transaction, genesisOutputIndex?: number): {
        codehash: string;
        genesis: string;
        sensibleId: string;
    };
    /**
     * Check if codehash is supported
     * @param codehash
     * @returns
     */
    static isSupportedToken(codehash: string): boolean;
    /**
     * Check if codehash and sensibleID is supported
     * @param codehash
     * @param sensibleId
     * @returns
     */
    isSupportedToken(codehash: string, sensibleId: string): Promise<boolean>;
    /**
     * parse a output script to get NFT info
     * @param scriptBuf
     * @param network
     * @returns
     */
    static parseTokenScript(scriptBuf: Buffer, network?: API_NET): {
        codehash: string;
        genesis: string;
        sensibleId: string;
        metaidOutpoint: nftProto.MetaidOutpoint;
        genesisFlag: number;
        nftAddress: string;
        totalSupply: BN;
        tokenIndex: BN;
        genesisHash: string;
        rabinPubKeyHashArrayHash: string;
        sensibleID: nftProto.SensibleID;
        protoVersion: number;
        protoType: number;
    };
    /**
     * query the supply info of NFT
     * @param sensibleId the sensibleId fo NFT
     * @returns
     */
    getSupplyInfo(sensibleId: string): Promise<{
        totalSupply: string;
        circulation: string;
    }>;
    /**
     * Query sell list of NFT tokens
     * @param codehash the codehash of NFT
     * @param genesis the genesis of NFT
     * @param cursor cursor
     * @param size size of page
     * @returns
     */
    getSellList(codehash: string, genesis: string, cursor?: number, size?: number): Promise<import("../sensible-api").NftSellUtxo[]>;
    /**
     * Query sell list of NFT tokens by seller's address
     * @param address seller's address
     * @param cursor cursor
     * @param size size of page
     * @returns
     */
    getSellListByAddress(address: string, cursor?: number, size?: number): Promise<import("../sensible-api").NftSellUtxo[]>;
}
export {};
