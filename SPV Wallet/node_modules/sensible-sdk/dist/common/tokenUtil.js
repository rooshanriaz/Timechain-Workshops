"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutpointBuf = exports.getRabinPubKeyHashArray = exports.getGenesisHashFromLockingScript = exports.getLockingScriptFromPreimage = exports.writeVarint = exports.getScriptHashBuf = exports.getTxIdBuf = exports.getUInt64Buf = exports.getUInt32Buf = exports.getUInt16Buf = exports.getUInt8Buf = exports.toBufferLE = exports.RABIN_SIG_LEN = void 0;
const bsv = require("../bsv");
const BN = require("../bn.js");
exports.RABIN_SIG_LEN = 384;
let toBufferLE = function (num, width) {
    const hex = num.toString(16);
    const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    buffer.reverse();
    return buffer;
};
exports.toBufferLE = toBufferLE;
let getUInt8Buf = function (amount) {
    const buf = Buffer.alloc(1, 0);
    buf.writeUInt8(amount);
    return buf;
};
exports.getUInt8Buf = getUInt8Buf;
let getUInt16Buf = function (amount) {
    const buf = Buffer.alloc(2, 0);
    buf.writeUInt16LE(amount);
    return buf;
};
exports.getUInt16Buf = getUInt16Buf;
let getUInt32Buf = function (index) {
    const buf = Buffer.alloc(4, 0);
    buf.writeUInt32LE(index);
    return buf;
};
exports.getUInt32Buf = getUInt32Buf;
let getUInt64Buf = function (amount) {
    return new BN(amount.toString()).toBuffer({ endian: "little", size: 8 });
};
exports.getUInt64Buf = getUInt64Buf;
let getTxIdBuf = function (txid) {
    const buf = Buffer.from(txid, "hex").reverse();
    return buf;
};
exports.getTxIdBuf = getTxIdBuf;
let getScriptHashBuf = function (scriptBuf) {
    const buf = Buffer.from(bsv.crypto.Hash.sha256ripemd160(scriptBuf));
    return buf;
};
exports.getScriptHashBuf = getScriptHashBuf;
let writeVarint = function (buf) {
    const n = buf.length;
    let header;
    let res = Buffer.alloc(0);
    if (n < 0xfd) {
        header = (0, exports.getUInt8Buf)(n);
    }
    else if (n < 0x10000) {
        header = Buffer.concat([Buffer.from("fd", "hex"), (0, exports.getUInt16Buf)(n)]);
    }
    else if (n < 0x100000000) {
        header = Buffer.concat([Buffer.from("fe", "hex"), (0, exports.getUInt32Buf)(n)]);
    }
    else if (n < 0x10000000000000000) {
        header = Buffer.concat([Buffer.from("ff", "hex"), (0, exports.getUInt64Buf)(n)]);
    }
    return Buffer.concat([header, buf]);
};
exports.writeVarint = writeVarint;
let getLockingScriptFromPreimage = function (buf) {
    const offset = 4 + 32 + 32 + 32 + 4;
    buf = buf.slice(offset, buf.length);
    const n = buf[0];
    buf = buf.slice(1, buf.length);
    let lockingScriptBuf;
    if (n < 0xfd) {
        let len = buf.slice(0, 1).readInt8(0);
        lockingScriptBuf = buf.slice(1, len + 1);
    }
    else if (n < 0x10000) {
        let len = buf.slice(0, 2).readInt16LE(0);
        lockingScriptBuf = buf.slice(2, len + 2);
    }
    else if (n < 0x100000000) {
        let len = buf.slice(0, 3).readInt32LE(0);
        lockingScriptBuf = buf.slice(3, len + 3);
    }
    else if (n < 0x10000000000000000) {
        let len = buf.slice(0, 4).readInt32LE(0);
        lockingScriptBuf = buf.slice(4, len + 4);
    }
    return lockingScriptBuf;
};
exports.getLockingScriptFromPreimage = getLockingScriptFromPreimage;
let getGenesisHashFromLockingScript = function (lockingScript) {
    let genesisHash;
    let c = 0;
    for (let i = 0; i < lockingScript.chunks.length; i++) {
        let chunk = lockingScript.chunks[i];
        if (chunk.buf && chunk.buf.length == 20) {
            c++;
            if (c == 11) {
                genesisHash = chunk.buf;
                break;
            }
        }
    }
    return genesisHash;
};
exports.getGenesisHashFromLockingScript = getGenesisHashFromLockingScript;
let getRabinPubKeyHashArray = function (rabinPubKeys) {
    let buf = Buffer.alloc(0);
    for (let i = 0; i < rabinPubKeys.length; i++) {
        buf = Buffer.concat([
            buf,
            bsv.crypto.Hash.sha256ripemd160(this.toBufferLE(rabinPubKeys[i].toString(16), this.RABIN_SIG_LEN)),
        ]);
    }
    return buf;
};
exports.getRabinPubKeyHashArray = getRabinPubKeyHashArray;
function getOutpointBuf(txid, index) {
    const txidBuf = Buffer.from(txid, "hex").reverse();
    const indexBuf = Buffer.alloc(4, 0);
    indexBuf.writeUInt32LE(index);
    let buf = Buffer.concat([txidBuf, indexBuf]);
    return buf;
}
exports.getOutpointBuf = getOutpointBuf;
