"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectSigners = exports.getRabinDatas = exports.getRabinData = exports.getRabinDataEmpty = void 0;
const BN = require("../bn.js");
const scryptlib_1 = require("../scryptlib");
const error_1 = require("./error");
const SatotxSigner_1 = require("./SatotxSigner");
const TokenUtil = require("./tokenUtil");
function getRabinDataEmpty(signers, signerSelecteds) {
    return __awaiter(this, void 0, void 0, function* () {
        let rabinMsg;
        let rabinPaddingArray = [];
        let rabinSigArray = [];
        rabinMsg = new scryptlib_1.Bytes("");
        signerSelecteds.forEach((v) => {
            rabinPaddingArray.push(new scryptlib_1.Bytes(""));
            rabinSigArray.push(new scryptlib_1.Int(0));
        });
        let rabinPubKeyIndexArray = signerSelecteds;
        let rabinPubKeyVerifyArray = [];
        rabinPubKeyIndexArray.forEach((signerIndex) => {
            rabinPubKeyVerifyArray.push(new scryptlib_1.Int(signers[signerIndex].satotxPubKey.toString(10)));
        });
        return {
            rabinData: {
                rabinMsg,
                rabinPaddingArray,
                rabinSigArray,
            },
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray,
        };
    });
}
exports.getRabinDataEmpty = getRabinDataEmpty;
function getRabinData(signers, signerSelecteds, rabinUtxo) {
    return __awaiter(this, void 0, void 0, function* () {
        let rabinMsg;
        let rabinPaddingArray = [];
        let rabinSigArray = [];
        let rabinPubKeyIndexArray = signerSelecteds;
        let rabinPubKeyVerifyArray = [];
        if (!rabinUtxo) {
            rabinMsg = new scryptlib_1.Bytes("");
            for (let i = 0; i < rabinPubKeyIndexArray.length; i++) {
                rabinPaddingArray.push(new scryptlib_1.Bytes(""));
                rabinSigArray.push(new scryptlib_1.Int(0));
            }
        }
        else {
            let sigReqArray = [];
            rabinPubKeyIndexArray.forEach((signerIndex) => {
                sigReqArray.push(signers[signerIndex].satoTxSigUTXOSpendBy({
                    txId: rabinUtxo.preTxId,
                    index: rabinUtxo.preOutputIndex,
                    txHex: rabinUtxo.preTxHex,
                    byTxId: rabinUtxo.txId,
                    byTxHex: rabinUtxo.txHex,
                }));
            });
            for (let j = 0; j < sigReqArray.length; j++) {
                let sigInfo = yield sigReqArray[j];
                if (j == 0) {
                    rabinMsg = new scryptlib_1.Bytes(sigInfo.payload);
                }
                rabinSigArray.push(new scryptlib_1.Int(BN.fromString(sigInfo.sigBE, 16).toString(10)));
                rabinPaddingArray.push(new scryptlib_1.Bytes(sigInfo.padding));
            }
        }
        rabinPubKeyIndexArray.forEach((signerIndex) => {
            rabinPubKeyVerifyArray.push(new scryptlib_1.Int(signers[signerIndex].satotxPubKey.toString(10)));
        });
        return {
            rabinData: {
                rabinMsg,
                rabinPaddingArray,
                rabinSigArray,
            },
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray,
        };
    });
}
exports.getRabinData = getRabinData;
function getRabinDatas(signers, signerSelecteds, rabinInputs) {
    return __awaiter(this, void 0, void 0, function* () {
        let rabinDatas = [];
        let checkRabinData = {
            rabinMsg: new scryptlib_1.Bytes(""),
            rabinPaddingArray: [],
            rabinSigArray: [],
        };
        let checkRabinMsgArray = Buffer.alloc(0);
        let checkRabinPaddingArray = Buffer.alloc(0);
        let checkRabinSigArray = Buffer.alloc(0);
        let rabinPubKeyIndexArray = signerSelecteds;
        let rabinPubKeyVerifyArray = [];
        let sigReqArray = [];
        for (let i = 0; i < rabinInputs.length; i++) {
            let v = rabinInputs[i];
            sigReqArray[i] = [];
            rabinPubKeyIndexArray.forEach((signerIndex) => {
                sigReqArray[i].push(signers[signerIndex].satoTxSigUTXOSpendByUTXO({
                    txId: v.preTxId,
                    index: v.preOutputIndex,
                    txHex: v.preTxHex,
                    byTxIndex: v.outputIndex,
                    byTxId: v.txId,
                    byTxHex: v.txHex,
                }));
            });
        }
        //Rabin Signature informations provided to TransferCheck/UnlockCheck
        for (let i = 0; i < sigReqArray.length; i++) {
            for (let j = 0; j < sigReqArray[i].length; j++) {
                let sigInfo = yield sigReqArray[i][j];
                if (j == 0) {
                    checkRabinMsgArray = Buffer.concat([
                        checkRabinMsgArray,
                        Buffer.from(sigInfo.byTxPayload, "hex"),
                    ]);
                    checkRabinData.rabinMsg = new scryptlib_1.Bytes(sigInfo.byTxPayload);
                }
                const sigBuf = TokenUtil.toBufferLE(sigInfo.byTxSigBE, TokenUtil.RABIN_SIG_LEN);
                checkRabinSigArray = Buffer.concat([checkRabinSigArray, sigBuf]);
                const paddingCountBuf = Buffer.alloc(2, 0);
                paddingCountBuf.writeUInt16LE(sigInfo.byTxPadding.length / 2);
                const padding = Buffer.alloc(sigInfo.byTxPadding.length / 2, 0);
                padding.write(sigInfo.byTxPadding, "hex");
                checkRabinPaddingArray = Buffer.concat([
                    checkRabinPaddingArray,
                    paddingCountBuf,
                    padding,
                ]);
                checkRabinData.rabinSigArray.push(new scryptlib_1.Int(BN.fromString(sigInfo.byTxSigBE, 16).toString(10)));
                checkRabinData.rabinPaddingArray.push(new scryptlib_1.Bytes(sigInfo.byTxPadding));
            }
        }
        //Rabin Signature informations provided to Token
        for (let i = 0; i < sigReqArray.length; i++) {
            let rabinMsg;
            let rabinSigArray = [];
            let rabinPaddingArray = [];
            for (let j = 0; j < sigReqArray[i].length; j++) {
                let sigInfo = yield sigReqArray[i][j];
                rabinMsg = new scryptlib_1.Bytes(sigInfo.payload);
                rabinSigArray.push(new scryptlib_1.Int(BN.fromString(sigInfo.sigBE, 16).toString(10)));
                rabinPaddingArray.push(new scryptlib_1.Bytes(sigInfo.padding));
            }
            rabinDatas.push({
                rabinMsg,
                rabinSigArray,
                rabinPaddingArray,
            });
        }
        rabinPubKeyIndexArray.forEach((signerIndex) => {
            rabinPubKeyVerifyArray.push(new scryptlib_1.Int(signers[signerIndex].satotxPubKey.toString(10)));
        });
        return {
            rabinDatas,
            checkRabinDatas: {
                rabinMsgArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(checkRabinMsgArray)),
                rabinPaddingArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(checkRabinPaddingArray)),
                rabinSigArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(checkRabinSigArray)),
            },
            checkRabinData,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray,
        };
    });
}
exports.getRabinDatas = getRabinDatas;
function selectSigners(signerConfigs, signerNum, signerVerifyNum) {
    return __awaiter(this, void 0, void 0, function* () {
        let _signerConfigs = signerConfigs.map((v) => Object.assign({}, v));
        if (_signerConfigs.length < signerNum) {
            throw new error_1.CodeError(error_1.ErrCode.EC_INVALID_ARGUMENT, `The length of signerArray should be ${signerNum}`);
        }
        let retPromises = [];
        for (let i = 0; i < _signerConfigs.length; i++) {
            let signerConfig = _signerConfigs[i];
            let subArray = signerConfig.satotxApiPrefix.split(",");
            let ret = new Promise((resolve, reject) => {
                let hasResolve = false;
                let failedCnt = 0;
                for (let j = 0; j < subArray.length; j++) {
                    let url = subArray[j];
                    let signer = new SatotxSigner_1.SatotxSigner(url);
                    signer
                        .getInfo()
                        .then(() => {
                        if (!hasResolve) {
                            hasResolve = true;
                            resolve({ url, idx: i });
                        }
                    })
                        .catch((e) => {
                        failedCnt++;
                        if (failedCnt == subArray.length) {
                            reject(e);
                        }
                    });
                }
            });
            retPromises.push(ret);
        }
        let getSelected = new Promise((resolve, reject) => {
            let signerSelecteds = [];
            let hasResolve = false;
            let successCnt = 0;
            let failedCnt = 0;
            for (let j = 0; j < retPromises.length; j++) {
                retPromises[j]
                    .then(({ idx, url }) => {
                    successCnt++;
                    _signerConfigs[idx].satotxApiPrefix = url;
                    if (signerSelecteds.length < signerVerifyNum) {
                        signerSelecteds.push(idx);
                    }
                    if (!hasResolve && successCnt == signerVerifyNum) {
                        hasResolve = true;
                        resolve(signerSelecteds);
                    }
                })
                    .catch((e) => {
                    failedCnt++;
                    if (failedCnt + successCnt == retPromises.length) {
                        reject(new error_1.CodeError(error_1.ErrCode.EC_INNER_ERROR, `Less than ${signerVerifyNum} successful signer requests`));
                    }
                });
            }
        });
        let signerSelecteds = yield getSelected;
        signerSelecteds.sort((a, b) => a - b);
        return {
            signers: _signerConfigs,
            signerSelecteds,
        };
    });
}
exports.selectSigners = selectSigners;
