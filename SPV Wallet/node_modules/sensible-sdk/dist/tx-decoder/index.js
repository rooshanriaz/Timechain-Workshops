"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxDecoder = exports.OutputType = void 0;
const bcp01_1 = require("../bcp01");
const bcp02_1 = require("../bcp02");
const proto = require("../common/protoheader");
const sensible_api_1 = require("../sensible-api");
var OutputType;
(function (OutputType) {
    OutputType[OutputType["SENSIBLE_NFT"] = 0] = "SENSIBLE_NFT";
    OutputType[OutputType["SENSIBLE_FT"] = 1] = "SENSIBLE_FT";
    OutputType[OutputType["P2PKH"] = 2] = "P2PKH";
    OutputType[OutputType["OP_RETURN"] = 3] = "OP_RETURN";
    OutputType[OutputType["UNKNOWN"] = 4] = "UNKNOWN";
})(OutputType = exports.OutputType || (exports.OutputType = {}));
class TxDecoder {
    static decodeOutput(output, network) {
        let scriptBuf = output.script.toBuffer();
        if (proto.hasProtoFlag(scriptBuf)) {
            let protoType = proto.getProtoType(scriptBuf);
            if (protoType == proto.PROTO_TYPE.NFT) {
                return {
                    type: OutputType.SENSIBLE_NFT,
                    satoshis: output.satoshis,
                    data: bcp01_1.SensibleNFT.parseTokenScript(scriptBuf, network),
                };
            }
            else if (protoType == proto.PROTO_TYPE.FT) {
                return {
                    type: OutputType.SENSIBLE_FT,
                    satoshis: output.satoshis,
                    data: bcp02_1.SensibleFT.parseTokenScript(scriptBuf, network),
                };
            }
            else {
                return {
                    type: OutputType.UNKNOWN,
                    satoshis: output.satoshis,
                };
            }
        }
        else if (output.script.isPublicKeyHashOut()) {
            return {
                type: OutputType.P2PKH,
                satoshis: output.satoshis,
                address: output.script.toAddress(network).toString(),
            };
        }
        else if (output.script.isSafeDataOut()) {
            return {
                type: OutputType.OP_RETURN,
                satoshis: 0,
            };
        }
        else {
            return {
                type: OutputType.UNKNOWN,
                satoshis: output.satoshis,
            };
        }
    }
    static decodeTx(tx, network = sensible_api_1.API_NET.MAIN) {
        let inputs = [];
        tx.inputs.forEach((v) => {
            if (v.output) {
                inputs.push(this.decodeOutput(v.output, network));
            }
        });
        let outputs = [];
        tx.outputs.forEach((v) => {
            outputs.push(this.decodeOutput(v, network));
        });
        let fee = inputs.reduce((pre, cur) => pre + cur.satoshis, 0) -
            outputs.reduce((pre, cur) => pre + cur.satoshis, 0);
        return {
            txId: tx.id,
            inputs,
            outputs,
            fee,
        };
    }
}
exports.TxDecoder = TxDecoder;
