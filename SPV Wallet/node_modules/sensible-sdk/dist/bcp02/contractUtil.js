"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractUtil = void 0;
const scryptlib_1 = require("scryptlib");
const bsv = require("../bsv");
const token_1 = require("./contract-factory/token");
const tokenGenesis_1 = require("./contract-factory/tokenGenesis");
const tokenTransferCheck_1 = require("./contract-factory/tokenTransferCheck");
const tokenUnlockContractCheck_1 = require("./contract-factory/tokenUnlockContractCheck");
function getTokenTransferCheckCodeHashArray() {
    let contractArray = [
        tokenTransferCheck_1.TokenTransferCheckFactory.createContract(tokenTransferCheck_1.TOKEN_TRANSFER_TYPE.IN_3_OUT_3),
        tokenTransferCheck_1.TokenTransferCheckFactory.createContract(tokenTransferCheck_1.TOKEN_TRANSFER_TYPE.IN_6_OUT_6),
        tokenTransferCheck_1.TokenTransferCheckFactory.createContract(tokenTransferCheck_1.TOKEN_TRANSFER_TYPE.IN_10_OUT_10),
        tokenTransferCheck_1.TokenTransferCheckFactory.createContract(tokenTransferCheck_1.TOKEN_TRANSFER_TYPE.IN_20_OUT_3),
        tokenTransferCheck_1.TokenTransferCheckFactory.createContract(tokenTransferCheck_1.TOKEN_TRANSFER_TYPE.IN_3_OUT_100),
    ];
    return contractArray.map((v) => v.getCodeHash());
}
function getTokenUnlockContractCheckCodeHashArray() {
    let contractArray = [
        tokenUnlockContractCheck_1.TokenUnlockContractCheckFactory.createContract(tokenUnlockContractCheck_1.TOKEN_UNLOCK_TYPE.IN_2_OUT_5),
        tokenUnlockContractCheck_1.TokenUnlockContractCheckFactory.createContract(tokenUnlockContractCheck_1.TOKEN_UNLOCK_TYPE.IN_4_OUT_8),
        tokenUnlockContractCheck_1.TokenUnlockContractCheckFactory.createContract(tokenUnlockContractCheck_1.TOKEN_UNLOCK_TYPE.IN_8_OUT_12),
        tokenUnlockContractCheck_1.TokenUnlockContractCheckFactory.createContract(tokenUnlockContractCheck_1.TOKEN_UNLOCK_TYPE.IN_20_OUT_5),
        tokenUnlockContractCheck_1.TokenUnlockContractCheckFactory.createContract(tokenUnlockContractCheck_1.TOKEN_UNLOCK_TYPE.IN_3_OUT_100),
    ];
    return contractArray.map((v) => v.getCodeHash());
}
class ContractUtil {
    static init(config) {
        if (config) {
            this.transferCheckCodeHashArray = config.transferCheckCodeHashArray.map((v) => new scryptlib_1.Bytes(v));
            this.unlockContractCodeHashArray = config.unlockContractCodeHashArray.map((v) => new scryptlib_1.Bytes(v));
            tokenGenesis_1.TokenGenesisFactory.lockingScriptSize = config.tokenGenesisSize;
            token_1.TokenFactory.lockingScriptSize = config.tokenSize;
            tokenTransferCheck_1.TokenTransferCheckFactory.tokenTransferTypeInfos.forEach((v, idx) => {
                v.lockingScriptSize = config.tokenTransferCheckSizes[idx];
            });
        }
        else {
            this.transferCheckCodeHashArray = getTokenTransferCheckCodeHashArray().map((v) => new scryptlib_1.Bytes(v));
            this.unlockContractCodeHashArray = getTokenUnlockContractCheckCodeHashArray().map((v) => new scryptlib_1.Bytes(v));
            tokenGenesis_1.TokenGenesisFactory.lockingScriptSize = tokenGenesis_1.TokenGenesisFactory.calLockingScriptSize();
            token_1.TokenFactory.lockingScriptSize = token_1.TokenFactory.calLockingScriptSize();
            tokenTransferCheck_1.TokenTransferCheckFactory.tokenTransferTypeInfos.forEach((v, idx) => {
                v.lockingScriptSize = tokenTransferCheck_1.TokenTransferCheckFactory.calLockingScriptSize(v.type);
            });
        }
        let tokenContract = token_1.TokenFactory.getDummyInstance();
        tokenContract.setDataPart("");
        let scriptBuf = tokenContract.lockingScript.toBuffer();
        this.tokenCodeHash = (0, scryptlib_1.toHex)(bsv.crypto.Hash.sha256ripemd160(scriptBuf));
    }
}
exports.ContractUtil = ContractUtil;
