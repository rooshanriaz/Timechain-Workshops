import { ContractAdapter } from "../../common/ContractAdapter";
import { Bytes, FunctionCall, SigHashPreimage } from "../../scryptlib";
import * as proto from "../contract-proto/tokenUnlockContractCheck.proto";
export declare enum TOKEN_UNLOCK_TYPE {
    IN_2_OUT_5 = 1,
    IN_4_OUT_8 = 2,
    IN_8_OUT_12 = 3,
    IN_3_OUT_100 = 4,
    IN_20_OUT_5 = 5,
    UNSUPPORT = 6
}
export declare class TokenUnlockContractCheck extends ContractAdapter {
    constuctParams: {
        unlockType: TOKEN_UNLOCK_TYPE;
    };
    private _formatedDataPart;
    constructor(constuctParams: {
        unlockType: TOKEN_UNLOCK_TYPE;
    });
    clone(): TokenUnlockContractCheck;
    setFormatedDataPart(dataPart: proto.FormatedDataPart): void;
    getFormatedDataPart(): proto.FormatedDataPart;
    unlock({ txPreimage, tokenScript, prevouts, rabinMsgArray, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, inputTokenAddressArray, inputTokenAmountArray, nOutputs, tokenOutputIndexArray, tokenOutputSatoshiArray, otherOutputArray, }: {
        txPreimage: SigHashPreimage;
        tokenScript: Bytes;
        prevouts: Bytes;
        rabinMsgArray: Bytes;
        rabinPaddingArray: Bytes;
        rabinSigArray: Bytes;
        rabinPubKeyIndexArray: number[];
        rabinPubKeyVerifyArray: bigint | string[];
        rabinPubKeyHashArray: Bytes;
        inputTokenAddressArray: Bytes;
        inputTokenAmountArray: Bytes;
        nOutputs: number;
        tokenOutputIndexArray: Bytes;
        tokenOutputSatoshiArray: Bytes;
        otherOutputArray: Bytes;
    }): FunctionCall;
}
export declare class TokenUnlockContractCheckFactory {
    static getOptimumType(inCount: number, outCount: number): TOKEN_UNLOCK_TYPE;
    static createContract(unlockType: TOKEN_UNLOCK_TYPE): TokenUnlockContractCheck;
}
