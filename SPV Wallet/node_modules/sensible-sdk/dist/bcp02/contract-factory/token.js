"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenFactory = exports.Token = void 0;
const BN = require("../../bn.js");
const bsv = require("../../bsv");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const protoheader_1 = require("../../common/protoheader");
const TokenUtil = require("../../common/tokenUtil");
const utils_1 = require("../../common/utils");
const scryptlib_1 = require("../../scryptlib");
const ftProto = require("../contract-proto/token.proto");
const contractUtil_1 = require("../contractUtil");
class Token extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let desc = require("../contract-desc/token_desc.json");
        let ClassObj = (0, scryptlib_1.buildContractClass)(desc);
        let contract = new ClassObj(constuctParams.transferCheckCodeHashArray, constuctParams.unlockContractCodeHashArray);
        super(contract);
        this.constuctParams = constuctParams;
        this._formatedDataPart = {};
    }
    static fromASM(asm) {
        let desc = require("../contract-desc/token_desc.json");
        let ClassObj = (0, scryptlib_1.buildContractClass)(desc);
        let contract = ClassObj.fromASM(asm);
        return contract;
    }
    clone() {
        let contract = new Token(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        this._formatedDataPart.genesisFlag = ftProto.GENESIS_FLAG.FALSE;
        this._formatedDataPart.protoVersion = ftProto.PROTO_VERSION;
        this._formatedDataPart.protoType = protoheader_1.PROTO_TYPE.FT;
        super.setDataPart((0, scryptlib_1.toHex)(ftProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    unlock({ txPreimage, tokenInputIndex, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, checkInputIndex, checkScriptTx, nReceivers, prevTokenAddress, prevTokenAmount, senderPubKey, senderSig, lockContractInputIndex, lockContractTx, operation, }) {
        if (operation != ftProto.FT_OP_TYPE.TRANSFER) {
            senderPubKey = new scryptlib_1.PubKey("");
            senderSig = new scryptlib_1.Sig("");
        }
        if (operation != ftProto.FT_OP_TYPE.UNLOCK_FROM_CONTRACT) {
            lockContractInputIndex = 0;
            lockContractTx = new scryptlib_1.Bytes("");
        }
        return this._contract.unlock(txPreimage, tokenInputIndex, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, checkInputIndex, checkScriptTx, nReceivers, prevTokenAddress, prevTokenAmount, senderPubKey, senderSig, lockContractInputIndex, lockContractTx, operation);
    }
}
exports.Token = Token;
class TokenFactory {
    static getLockingScriptSize() {
        return this.lockingScriptSize;
    }
    static createContract(transferCheckCodeHashArray, unlockContractCodeHashArray) {
        return new Token({
            transferCheckCodeHashArray,
            unlockContractCodeHashArray,
        });
    }
    static getDummyInstance() {
        let contract = this.createContract(contractUtil_1.ContractUtil.transferCheckCodeHashArray, contractUtil_1.ContractUtil.unlockContractCodeHashArray);
        contract.setFormatedDataPart({});
        return contract;
    }
    static calLockingScriptSize() {
        let contract = this.getDummyInstance();
        return contract.lockingScript.toBuffer().length;
    }
    static calUnlockingScriptSize(routeCheckContact, bsvInputLen, tokenInputLen, tokenOutputLen) {
        let contract = this.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const sig = Buffer.from(utils_1.PLACE_HOLDER_SIG, "hex");
        const rabinMsg = dummy_1.dummyPayload;
        const rabinPaddingArray = [];
        const rabinSigArray = [];
        const rabinPubKeyIndexArray = [];
        const rabinPubKeyArray = [];
        for (let i = 0; i < ftProto.SIGNER_VERIFY_NUM; i++) {
            rabinPaddingArray.push(new scryptlib_1.Bytes(dummy_1.dummyPadding));
            rabinSigArray.push(new scryptlib_1.Int(BN.fromString(dummy_1.dummySigBE, 16).toString(10)));
            rabinPubKeyIndexArray.push(i);
            rabinPubKeyArray.push(new scryptlib_1.Int(dummy_1.dummyRabinPubKey.toString(10)));
        }
        const tokenInputIndex = 0;
        let prevouts = Buffer.alloc(0);
        const indexBuf = TokenUtil.getUInt32Buf(0);
        const txidBuf = TokenUtil.getTxIdBuf(dummy_1.dummyTxId);
        for (let i = 0; i < tokenInputLen + bsvInputLen + 1; i++) {
            prevouts = Buffer.concat([prevouts, txidBuf, indexBuf]);
        }
        const routeCheckInputIndex = 0;
        let routeCheckTx = new bsv.Transaction(dummy_1.dummyTx.serialize(true));
        routeCheckTx.addOutput(new bsv.Transaction.Output({
            script: routeCheckContact.lockingScript,
            satoshis: 10000,
        }));
        let unlockedContract = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            tokenInputIndex,
            prevouts: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(prevouts)),
            rabinMsg: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(rabinMsg)),
            rabinPaddingArray,
            rabinSigArray,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray: rabinPubKeyArray,
            rabinPubKeyHashArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyRabinPubKeyHashArray)),
            checkInputIndex: routeCheckInputIndex,
            checkScriptTx: new scryptlib_1.Bytes(routeCheckTx.serialize(true)),
            nReceivers: tokenOutputLen,
            prevTokenAddress: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            prevTokenAmount: new scryptlib_1.Int("1000000000"),
            senderPubKey: new scryptlib_1.PubKey((0, scryptlib_1.toHex)(dummy_1.dummyPk)),
            senderSig: new scryptlib_1.Sig((0, scryptlib_1.toHex)(sig)),
            lockContractInputIndex: 0,
            lockContractTx: new scryptlib_1.Bytes("00"),
            operation: ftProto.FT_OP_TYPE.TRANSFER,
        });
        return unlockedContract.toScript().toBuffer().length;
    }
}
exports.TokenFactory = TokenFactory;
