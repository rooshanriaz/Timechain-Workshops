"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTypeResolver = exports.buildTypeClasses = exports.buildStructsClass = exports.buildContractClass = exports.AbstractContract = void 0;
var abi_1 = require("./abi");
var serializer_1 = require("./serializer");
var utils_1 = require("./utils");
var scryptTypes_1 = require("./scryptTypes");
var compilerWrapper_1 = require("./compilerWrapper");
var AbstractContract = /** @class */ (function () {
    function AbstractContract() {
        this.calls = new Map();
        this.asmArgs = null;
    }
    Object.defineProperty(AbstractContract.prototype, "lockingScript", {
        get: function () {
            var lsASM = this.scriptedConstructor.toASM();
            if (typeof this._dataPart === 'string') {
                var dp = this._dataPart.trim();
                if (dp) {
                    lsASM += " OP_RETURN " + dp;
                }
                else {
                    lsASM += ' OP_RETURN'; // note there is no space after op_return
                }
            }
            return utils_1.bsv.Script.fromASM(lsASM.trim());
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "txContext", {
        get: function () {
            return this._txContext;
        },
        set: function (txContext) {
            this._txContext = txContext;
        },
        enumerable: false,
        configurable: true
    });
    // replace assembly variables with assembly values
    AbstractContract.prototype.replaceAsmVars = function (asmVarValues) {
        this.asmArgs = asmVarValues;
        this.scriptedConstructor.init(asmVarValues);
    };
    AbstractContract.findSrcInfo = function (interpretStates, opcodes, stepIndex, opcodesIndex) {
        while (--stepIndex > 0 && --opcodesIndex > 0) {
            if (opcodes[opcodesIndex].pos && opcodes[opcodesIndex].pos.file !== 'std' && opcodes[opcodesIndex].pos.line > 0 && interpretStates[stepIndex].step.fExec) {
                return opcodes[opcodesIndex];
            }
        }
    };
    AbstractContract.prototype.getTypeClassByType = function (type) {
        var types = Object.getPrototypeOf(this).constructor.types;
        if (utils_1.isStructType(type)) {
            var structName = utils_1.getStructNameByType(type);
            if (Object.prototype.hasOwnProperty.call(types, structName)) {
                return types[structName];
            }
        }
        else {
            return types[type];
        }
    };
    AbstractContract.prototype.run_verify = function (unlockingScriptASM, txContext, args) {
        var txCtx = Object.assign({}, this._txContext || {}, txContext || {});
        var us = utils_1.bsv.Script.fromASM(unlockingScriptASM.trim());
        var ls = this.lockingScript;
        var tx = txCtx.tx;
        var inputIndex = txCtx.inputIndex || 0;
        var inputSatoshis = txCtx.inputSatoshis || 0;
        utils_1.bsv.Script.Interpreter.MAX_SCRIPT_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
        utils_1.bsv.Script.Interpreter.MAXIMUM_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
        var bsi = utils_1.bsv.Script.Interpreter();
        var stepCounter = 0;
        var interpretStates = [];
        bsi.stepListener = function (step, stack, altstack) {
            interpretStates.push({ mainstack: stack, altstack: altstack, step: step });
            stepCounter++;
        };
        var opcodes = Object.getPrototypeOf(this).constructor.opcodes;
        var result = bsi.verify(us, ls, tx, inputIndex, utils_1.DEFAULT_FLAGS, new utils_1.bsv.crypto.BN(inputSatoshis));
        var error = result ? '' : "VerifyError: " + bsi.errstr;
        // some time there is no opcodes, such as when sourcemap flag is closeed. 
        if (opcodes) {
            var offset = unlockingScriptASM.trim().split(' ').length;
            // the complete script may have op_return and data, but compiled output does not have it. So we need to make sure the index is in boundary.
            var lastStepIndex = stepCounter - 1;
            if (typeof this._dataPart === 'string') {
                opcodes.push({ opcode: 'OP_RETURN', stack: [] });
                var dp = this._dataPart.trim();
                if (dp) {
                    dp.split(' ').forEach(function (data) {
                        opcodes.push({ opcode: data, stack: [] });
                    });
                }
            }
            var opcodeIndex = lastStepIndex - offset;
            if (!result && opcodes[opcodeIndex]) {
                var opcode = opcodes[opcodeIndex];
                if (!opcode.pos || opcode.pos.file === 'std') {
                    var srcInfo = AbstractContract.findSrcInfo(interpretStates, opcodes, lastStepIndex, opcodeIndex);
                    if (srcInfo) {
                        opcode.pos = srcInfo.pos;
                    }
                }
                // in vscode termianal need to use [:] to jump to file line, but here need to use [#] to jump to file line in output channel.
                if (opcode.pos) {
                    error = "VerifyError: " + bsi.errstr + " \n\t[Go to Source](" + utils_1.path2uri(opcode.pos.file) + "#" + opcode.pos.line + ")  fails at " + opcode.opcode + "\n";
                    if (args && ['OP_CHECKSIG', 'OP_CHECKSIGVERIFY', 'OP_CHECKMULTISIG', 'OP_CHECKMULTISIGVERIFY'].includes(opcode.opcode)) {
                        if (!txCtx) {
                            throw new Error('should provide txContext when verify');
                        }
                        if (!tx) {
                            throw new Error('should provide txContext.tx when verify');
                        }
                    }
                }
            }
        }
        return {
            success: result,
            error: error
        };
    };
    Object.defineProperty(AbstractContract.prototype, "dataPart", {
        get: function () {
            return this._dataPart !== undefined ? utils_1.bsv.Script.fromASM(this._dataPart) : undefined;
        },
        set: function (dataInScript) {
            throw new Error('Setter for dataPart is not available. Please use: setDataPart() instead');
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.prototype.setDataPart = function (state) {
        if (typeof state === 'string') {
            // TODO: validate hex string
            this._dataPart = state.trim();
        }
        else {
            this._dataPart = serializer_1.serializeState(state);
        }
    };
    Object.defineProperty(AbstractContract.prototype, "codePart", {
        get: function () {
            var codeASM = this.scriptedConstructor.toASM();
            // note: do not trim the trailing space
            return utils_1.bsv.Script.fromASM(codeASM + ' OP_RETURN');
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.getAsmVars = function (contractAsm, instAsm) {
        var regex = /(\$\S+)/g;
        var vars = contractAsm.match(regex);
        if (vars === null) {
            return null;
        }
        var asmArray = contractAsm.split(/\s/g);
        var lsASMArray = instAsm.split(/\s/g);
        var result = {};
        for (var i = 0; i < asmArray.length; i++) {
            for (var j = 0; j < vars.length; j++) {
                if (vars[j] === asmArray[i]) {
                    result[vars[j].replace('$', '')] = lsASMArray[i];
                }
            }
        }
        return result;
    };
    AbstractContract.prototype.arguments = function (pubFuncName) {
        if (pubFuncName === 'constructor') {
            return this.scriptedConstructor.args;
        }
        if (this.calls.has(pubFuncName)) {
            return this.calls.get(pubFuncName).args;
        }
        return [];
    };
    return AbstractContract;
}());
exports.AbstractContract = AbstractContract;
var invalidMethodName = ['arguments', 'setDataPart', 'run_verify', 'replaceAsmVars', 'asmVars', 'asmArguments', 'dataPart', 'lockingScript', 'txContext'];
function buildContractClass(desc) {
    if (!desc.contract) {
        throw new Error('missing field `contract` in description');
    }
    if (!desc.abi) {
        throw new Error('missing field `abi` in description');
    }
    if (!desc.asm) {
        throw new Error('missing field `asm` in description');
    }
    if (!desc['errors']) {
        desc = compilerWrapper_1.desc2CompileResult(desc);
    }
    else {
        desc = desc;
    }
    var ContractClass = /** @class */ (function (_super) {
        __extends(Contract, _super);
        function Contract() {
            var _a;
            var ctorParams = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ctorParams[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            if (!Contract.asmContract) {
                _this.scriptedConstructor = (_a = Contract.abiCoder).encodeConstructorCall.apply(_a, __spread([_this, Contract.asm], ctorParams));
            }
            return _this;
        }
        //When create a contract instance using UTXO, 
        //use fromHex or fromASM because you do not know the parameters of constructor.
        /**
         * Create a contract instance using UTXO asm
         * @param hex
         */
        Contract.fromASM = function (asm) {
            Contract.asmContract = true;
            var obj = new this();
            Contract.asmContract = false;
            obj.scriptedConstructor = Contract.abiCoder.encodeConstructorCallFromASM(obj, Contract.asm, asm);
            return obj;
        };
        /**
         * Create a contract instance using UTXO hex
         * @param hex
         */
        Contract.fromHex = function (hex) {
            return ContractClass.fromASM((new utils_1.bsv.Script(hex)).toASM());
        };
        /**
         * Create a contract instance using raw Transaction
         * @param hex
         */
        Contract.fromTransaction = function (hex, outputIndex) {
            if (outputIndex === void 0) { outputIndex = 0; }
            var tx = new utils_1.bsv.Transaction(hex);
            return ContractClass.fromHex(tx.outputs[outputIndex].script.toHex());
        };
        Object.defineProperty(Contract.prototype, "asmVars", {
            /**
             * Get the parameter of the constructor and inline asm vars,
             * all values is hex string, need convert it to number or bytes on using
             */
            get: function () {
                return AbstractContract.getAsmVars(Contract.asm, this.scriptedConstructor.toASM());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Contract.prototype, "asmArguments", {
            get: function () {
                //TODO: @deprecate AbstractContract.getAsmVars , using asmArguments
                return null;
            },
            enumerable: false,
            configurable: true
        });
        return Contract;
    }(AbstractContract));
    var staticConst = desc.staticConst || {};
    var finalTypeResolver = buildTypeResolver(desc.contract, desc.alias || [], desc.structs || [], staticConst);
    ContractClass.contractName = desc.contract;
    ContractClass.abi = desc.abi;
    ContractClass.asm = desc.asm.map(function (item) { return item['opcode'].trim(); }).join(' ');
    ContractClass.abiCoder = new abi_1.ABICoder(desc.abi, finalTypeResolver);
    ContractClass.opcodes = desc.asm;
    ContractClass.file = desc.file;
    ContractClass.structs = desc.structs;
    ContractClass.staticConst = staticConst;
    ContractClass.types = buildTypeClasses(desc);
    ContractClass.abi.forEach(function (entity) {
        if (invalidMethodName.indexOf(entity.name) > -1) {
            throw new Error("Method name [" + entity.name + "] is used by scryptlib now, Pelease change you contract method name!");
        }
        ContractClass.prototype[entity.name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var call = ContractClass.abiCoder.encodePubFunctionCall(this, entity.name, args);
            this.calls.set(entity.name, call);
            return call;
        };
    });
    return ContractClass;
}
exports.buildContractClass = buildContractClass;
/**
 * @deprecated use buildTypeClasses
 * @param desc CompileResult or ContractDescription
 */
function buildStructsClass(desc) {
    var structTypes = {};
    var structs = desc.structs || [];
    var alias = desc.alias || [];
    var finalTypeResolver = buildTypeResolver(desc.contract, alias, structs, desc['staticConst'] || {});
    structs.forEach(function (element) {
        var _a;
        var name = element.name;
        Object.assign(structTypes, (_a = {},
            _a[name] = /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1(o) {
                    var _this = _super.call(this, o) || this;
                    _this._typeResolver = finalTypeResolver; //we should assign this before bind
                    _this.bind();
                    return _this;
                }
                return class_1;
            }(scryptTypes_1.Struct)),
            _a));
        structTypes[name].structAst = element;
    });
    return structTypes;
}
exports.buildStructsClass = buildStructsClass;
function buildTypeClasses(desc) {
    var structClasses = buildStructsClass(desc);
    var aliasTypes = {};
    var alias = desc.alias || [];
    var structs = desc.structs || [];
    var finalTypeResolver = buildTypeResolver(desc.contract, alias, structs, desc['staticConst'] || {});
    alias.forEach(function (element) {
        var _a, _b, _c, _d;
        var finalType = finalTypeResolver(element.name);
        if (utils_1.isStructType(finalType)) {
            var type = utils_1.getStructNameByType(finalType);
            Object.assign(aliasTypes, (_a = {},
                _a[element.name] = /** @class */ (function (_super) {
                    __extends(class_2, _super);
                    function class_2(o) {
                        var _this = _super.call(this, o) || this;
                        _this._type = element.name;
                        _this._typeResolver = finalTypeResolver;
                        return _this;
                    }
                    return class_2;
                }(structClasses[type])),
                _a));
        }
        else if (utils_1.isArrayType(finalType)) {
            //TODO: just return some class, but they are useless
            var _e = __read(utils_1.arrayTypeAndSize(finalType), 2), elemTypeName = _e[0], _ = _e[1];
            var C = scryptTypes_1.BasicScryptType[elemTypeName];
            if (C) {
                Object.assign(aliasTypes, (_b = {},
                    _b[element.name] = /** @class */ (function (_super) {
                        __extends(class_3, _super);
                        function class_3() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        return class_3;
                    }(Array)),
                    _b));
            }
            else if (utils_1.isStructType(elemTypeName)) {
                var type = utils_1.getStructNameByType(elemTypeName);
                var C_1 = structClasses[type];
                Object.assign(aliasTypes, (_c = {},
                    _c[element.name] = /** @class */ (function (_super) {
                        __extends(class_4, _super);
                        function class_4() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        return class_4;
                    }(Array)),
                    _c));
            }
        }
        else {
            var C = scryptTypes_1.BasicScryptType[finalType];
            if (C) {
                var Class = C;
                var aliasClass = /** @class */ (function (_super) {
                    __extends(class_5, _super);
                    function class_5(o) {
                        var _this = _super.call(this, o) || this;
                        _this._type = element.name;
                        _this._typeResolver = finalTypeResolver;
                        return _this;
                    }
                    return class_5;
                }(Class));
                Object.assign(aliasTypes, (_d = {},
                    _d[element.name] = aliasClass,
                    _d));
            }
            else {
                throw new Error("can not resolve type alias " + element.name + " " + element.type);
            }
        }
    });
    Object.assign(aliasTypes, structClasses);
    return aliasTypes;
}
exports.buildTypeClasses = buildTypeClasses;
function buildTypeResolver(contract, alias, structs, staticConst) {
    var resolvedTypes = {};
    alias.forEach(function (element) {
        var type = utils_1.resolveType(alias, element.name);
        var finalType = utils_1.resolveStaticConst(contract, type, staticConst);
        resolvedTypes[element.name] = finalType;
    });
    structs.forEach(function (element) {
        resolvedTypes[element.name] = "struct " + element.name + " {}";
    });
    var resolver = function (type) {
        if (scryptTypes_1.BasicScryptType[type]) {
            return "" + type;
        }
        if (resolvedTypes[type]) {
            return "" + resolvedTypes[type];
        }
        if (utils_1.isArrayType(type)) {
            var finalType = utils_1.resolveStaticConst(contract, type, staticConst);
            var _a = __read(utils_1.arrayTypeAndSize(finalType), 2), elemTypeName = _a[0], sizes = _a[1];
            if (scryptTypes_1.BasicScryptType[elemTypeName]) {
                return utils_1.toLiteralArrayType(elemTypeName, sizes);
            }
            else if (resolvedTypes[elemTypeName]) {
                if (utils_1.isArrayType(resolvedTypes[elemTypeName])) {
                    var _b = __read(utils_1.arrayTypeAndSize(resolvedTypes[elemTypeName]), 2), elemTypeName_ = _b[0], sizes_ = _b[1];
                    return utils_1.toLiteralArrayType(elemTypeName_, sizes.concat(sizes_));
                }
                return utils_1.toLiteralArrayType(resolvedTypes[elemTypeName], sizes);
            }
            else if (utils_1.isStructType(elemTypeName)) {
                var structName = utils_1.getStructNameByType(elemTypeName);
                return resolver(utils_1.toLiteralArrayType(structName, sizes));
            }
            else {
                throw new Error('typeResolver with unknown elemTypeName ' + elemTypeName);
            }
        }
        else if (utils_1.isStructType(type)) {
            var structName = utils_1.getStructNameByType(type);
            return resolver(structName);
        }
        else {
            throw new Error('typeResolver with unknown type ' + type);
        }
    };
    return resolver;
}
exports.buildTypeResolver = buildTypeResolver;
//# sourceMappingURL=contract.js.map