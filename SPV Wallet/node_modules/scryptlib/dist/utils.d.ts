/// <reference types="node" />
import { Int, Bool, Bytes, PrivKey, PubKey, Sig, Ripemd160, Sha1, Sha256, SigHashType, SigHashPreimage, OpCodeType, ScryptType, ValueType, Struct, SupportedParamType, VariableType, TypeResolver } from './scryptTypes';
import { StructEntity, CompileResult, AliasEntity } from './compilerWrapper';
import bsv = require('bsv');
import ECIES = require('bsv/ecies');
import { AbstractContract, AsmVarValues, TxContext } from './contract';
import { FileUri } from './abi';
export { bsv };
export { ECIES };
export declare const DEFAULT_FLAGS: number;
export declare const DEFAULT_SIGHASH_TYPE: number;
export declare function bool2Asm(str: string): string;
/**
 * decimal or hex int to little-endian signed magnitude
 */
export declare function int2Asm(str: string): string;
/**
 * convert asm string to number or bigint
 */
export declare function asm2int(str: string): number | bigint | string;
/**
 * decimal int or hex str to number or bigint
 */
export declare function int2Value(str: string): number | bigint | string;
export declare function intValue2hex(val: number | bigint): string;
export declare function parseLiteral(l: string): [string, ValueType, VariableType];
/**
 * convert literals to Scrypt Type
 */
export declare function literal2ScryptType(l: string): ScryptType;
export declare function asm2ScryptType(type: string, asm: string): Bool | Int | Bytes | PubKey | PrivKey | Sig | Ripemd160 | Sha1 | Sha256 | SigHashType | OpCodeType | SigHashPreimage;
export declare function bytes2Literal(bytearray: number[], type: string): string;
export declare function bytesToHexString(bytearray: number[]): string;
export declare function hexStringToBytes(hex: string): number[];
export declare function getValidatedHexString(hex: string, allowEmpty?: boolean): string;
export declare function signTx(tx: any, privateKey: any, lockingScriptASM: string, inputAmount: number, inputIndex?: number, sighashType?: number, flags?: number): any;
export declare function toHex(x: {
    toString(format: 'hex'): string;
}): string;
export declare function getPreimage(tx: any, inputLockingScriptASM: string, inputAmount: number, inputIndex?: number, sighashType?: number, flags?: number): SigHashPreimage;
export declare function num2bin(n: number | bigint | bsv.crypto.BN, dataLen: number): string;
export declare function bin2num(s: string | Buffer): number | bigint | string;
export declare function isNode(): boolean;
export declare function path2uri(path: string): string;
export declare function uri2path(uri: string): string;
/**
 * @deprecated
 * convert literals to script ASM format
 */
export declare function literal2Asm(l: string): [string, string];
export declare function findStructByName(name: string, s: StructEntity[]): StructEntity;
export declare function isStructType(type: string): boolean;
export declare function isArrayType(type: string): boolean;
export declare function getStructNameByType(type: string): string;
export declare function findStructByType(type: string, s: StructEntity[]): StructEntity | undefined;
export declare function checkStruct(s: StructEntity, arg: Struct, typeResolver: TypeResolver): void;
/**
 * return eg. int[N][N][4] => ['int', ["N","N","4"]]
 * @param arrayTypeName
 */
export declare function arrayTypeAndSizeStr(arrayTypeName: string): [string, Array<string>];
/**
 * return eg. int[2][3][4] => ['int', [2,3,4]]
 * @param arrayTypeName  eg. int[2][3][4]
 */
export declare function arrayTypeAndSize(arrayTypeName: string): [string, Array<number>];
export declare function toLiteralArrayType(elemTypeName: string, sizes: Array<number | string>): string;
/**
 * return eg. int[2][3][4] => int[3][4]
 * @param arrayTypeName  eg. int[2][3][4]
 */
export declare function subArrayType(arrayTypeName: string): string;
export declare function checkArray(args: SupportedParamType[], arrayInfo: [string, Array<number>]): boolean;
export declare function subscript(index: number, arraySizes: Array<number>): string;
export declare function flatternArray(arg: Array<any>, name: string, finalType: string): Array<{
    value: ScryptType;
    name: string;
    type: string;
}>;
export declare function flatternStruct(arg: SupportedParamType, name: string): Array<{
    value: ScryptType;
    name: string;
    type: string;
}>;
export declare function typeOfArg(arg: SupportedParamType): string;
export declare function readFileByLine(path: string, index: number): string;
export declare function isEmpty(obj: unknown): boolean;
export declare function getCIScryptc(): string | undefined;
export declare function compileContract(file: string, options?: {
    out?: string;
    sourceMap?: boolean;
}): CompileResult;
export declare function newCall(Cls: any, args: Array<SupportedParamType>): any;
export declare function genLaunchConfigFile(constructorArgs: SupportedParamType[], pubFuncArgs: SupportedParamType[], pubFunc: string, name: string, program: string, txContext: TxContext, asmArgs: AsmVarValues): FileUri;
/***
 * resolve type
 */
export declare function resolveType(alias: AliasEntity[], type: string): string;
export declare function ansiRegex({ onlyFirst }?: {
    onlyFirst?: boolean;
}): RegExp;
export declare function stripAnsi(string: any): string;
export declare function createStruct(contract: AbstractContract, sType: typeof Struct, name: string, opcodesMap: Map<string, string>, finalTypeResolver: TypeResolver): Struct;
export declare function createArray(contract: AbstractContract, type: string, name: string, opcodesMap: Map<string, string>, finalTypeResolver: TypeResolver): any[];
export declare function toLiteral(value: ScryptType): string;
export declare function isInteger(x: unknown): boolean;
export declare function resolveStaticConst(contract: string, type: string, staticConstInt: Record<string, number>): string;
