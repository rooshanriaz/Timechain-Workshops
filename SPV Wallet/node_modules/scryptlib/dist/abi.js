"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ABICoder = exports.FunctionCall = void 0;
var utils_1 = require("./utils");
var scryptTypes_1 = require("./scryptTypes");
var compilerWrapper_1 = require("./compilerWrapper");
function escapeRegExp(stringToGoIntoTheRegex) {
    return stringToGoIntoTheRegex.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
var FunctionCall = /** @class */ (function () {
    function FunctionCall(methodName, params, binding) {
        this.methodName = methodName;
        this.params = params;
        this.args = [];
        if (binding.lockingScriptASM === undefined && binding.unlockingScriptASM === undefined) {
            throw new Error('param binding.lockingScriptASM & binding.unlockingScriptASM cannot both be empty');
        }
        this.contract = binding.contract;
        this.args = Object.getPrototypeOf(this.contract).constructor.abi.filter(function (entity) {
            if ('constructor' === methodName) {
                return entity.type === 'constructor';
            }
            return entity.name === methodName;
        }).map(function (entity) {
            return entity.params.map(function (param, index) {
                return {
                    name: param.name,
                    type: param.type,
                    value: params[index]
                };
            });
        }).flat(1);
        if (binding.lockingScriptASM) {
            this._lockingScriptAsm = binding.lockingScriptASM;
        }
        if (binding.unlockingScriptASM) {
            this._unlockingScriptAsm = binding.unlockingScriptASM;
        }
    }
    Object.defineProperty(FunctionCall.prototype, "unlockingScript", {
        get: function () {
            return this._unlockingScriptAsm === undefined ? undefined : utils_1.bsv.Script.fromASM(this._unlockingScriptAsm);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FunctionCall.prototype, "lockingScript", {
        get: function () {
            return this._lockingScriptAsm === undefined ? undefined : utils_1.bsv.Script.fromASM(this._lockingScriptAsm);
        },
        enumerable: false,
        configurable: true
    });
    FunctionCall.prototype.init = function (asmVarValues) {
        for (var key in asmVarValues) {
            var val = asmVarValues[key];
            var re = new RegExp("\\$" + key, 'g');
            this._lockingScriptAsm = this._lockingScriptAsm.replace(re, val);
        }
    };
    FunctionCall.prototype.toASM = function () {
        if (this.lockingScript) {
            return this.lockingScript.toASM();
        }
        else {
            return this.unlockingScript.toASM();
        }
    };
    FunctionCall.prototype.toString = function () {
        return this.toHex();
    };
    FunctionCall.prototype.toScript = function () {
        return utils_1.bsv.Script.fromASM(this.toASM());
    };
    FunctionCall.prototype.toHex = function () {
        return this.toScript().toHex();
    };
    FunctionCall.prototype.genLaunchConfigFile = function (txContext) {
        var constructorArgs = this.contract.scriptedConstructor.params;
        var pubFuncArgs = this.params;
        var pubFunc = this.methodName;
        var name = "Debug " + Object.getPrototypeOf(this.contract).constructor.contractName;
        var program = "" + Object.getPrototypeOf(this.contract).constructor.file;
        var asmArgs = this.contract.asmArgs || {};
        var dataPart = this.contract.dataPart ? this.contract.dataPart.toASM() : undefined;
        var txCtx = Object.assign({}, this.contract.txContext || {}, txContext || {}, { opReturn: dataPart });
        return utils_1.genLaunchConfigFile(constructorArgs, pubFuncArgs, pubFunc, name, program, txCtx, asmArgs);
    };
    FunctionCall.prototype.verify = function (txContext) {
        if (this.unlockingScript) {
            var result = this.contract.run_verify(this.unlockingScript.toASM(), txContext, this.args);
            if (!result.success) {
                var debugUrl = this.genLaunchConfigFile(txContext);
                if (debugUrl) {
                    result.error = result.error + ("\t[Launch Debugger](" + debugUrl.replace(/file:/i, 'scryptlaunch:') + ")\n");
                }
            }
            return result;
        }
        return {
            success: false,
            error: 'verification failed, missing unlockingScript'
        };
    };
    return FunctionCall;
}());
exports.FunctionCall = FunctionCall;
var ABICoder = /** @class */ (function () {
    function ABICoder(abi, finalTypeResolver) {
        this.abi = abi;
        this.finalTypeResolver = finalTypeResolver;
    }
    ABICoder.prototype.encodeConstructorCall = function (contract, asmTemplate) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var constructorABI = this.abi.filter(function (entity) { return entity.type === compilerWrapper_1.ABIEntityType.CONSTRUCTOR; })[0];
        var cParams = (constructorABI === null || constructorABI === void 0 ? void 0 : constructorABI.params) || [];
        if (args.length !== cParams.length) {
            throw new Error("wrong number of arguments for #constructor, expected " + cParams.length + " but got " + args.length);
        }
        // handle array type
        var cParams_ = [];
        var args_ = [];
        cParams.map(function (p) { return ({
            name: p.name,
            type: _this.finalTypeResolver(p.type)
        }); }).forEach(function (param, index) {
            var arg = args[index];
            if (utils_1.isArrayType(param.type)) {
                var _a = __read(utils_1.arrayTypeAndSize(param.type), 2), elemTypeName = _a[0], arraySizes = _a[1];
                if (Array.isArray(arg)) {
                    if (utils_1.checkArray(arg, [elemTypeName, arraySizes])) {
                        // flattern array
                        utils_1.flatternArray(arg, param.name, param.type).forEach(function (e) {
                            cParams_.push({ name: e.name, type: _this.finalTypeResolver(e.type) });
                            args_.push(e.value);
                        });
                    }
                    else {
                        throw new Error("constructor " + index + "-th parameter should be " + param.type);
                    }
                }
                else {
                    throw new Error("constructor " + index + "-th parameter should be " + param.type);
                }
            }
            else if (utils_1.isStructType(param.type)) {
                var argS = arg;
                if (param.type != argS.finalType) {
                    throw new Error("expect struct " + utils_1.getStructNameByType(param.type) + " but got struct " + argS.type);
                }
                utils_1.flatternStruct(argS, param.name).forEach(function (v) {
                    cParams_.push({ name: "" + v.name, type: _this.finalTypeResolver(v.type) });
                    args_.push(v.value);
                });
            }
            else {
                cParams_.push(param);
                args_.push(arg);
            }
        });
        var lsASM = asmTemplate;
        cParams_.forEach(function (param, index) {
            if (!asmTemplate.includes("$" + param.name)) {
                throw new Error("abi constructor params mismatch with args provided: missing " + param.name + " in ASM tempalte");
            }
            var re = param.name.endsWith(']') ? new RegExp("\\B" + escapeRegExp("$" + param.name) + "\\B", 'g') : new RegExp("\\B" + escapeRegExp("$" + param.name) + "\\b", 'g');
            lsASM = lsASM.replace(re, _this.encodeParam(args_[index], param));
        });
        return new FunctionCall('constructor', args, { contract: contract, lockingScriptASM: lsASM });
    };
    ABICoder.prototype.encodeConstructorCallFromASM = function (contract, asmTemplate, lsASM) {
        var _this = this;
        var constructorABI = this.abi.filter(function (entity) { return entity.type === compilerWrapper_1.ABIEntityType.CONSTRUCTOR; })[0];
        var cParams = (constructorABI === null || constructorABI === void 0 ? void 0 : constructorABI.params) || [];
        var contractName = Object.getPrototypeOf(contract).constructor.contractName;
        var opcodesMap = new Map();
        var asmTemplateOpcodes = asmTemplate.split(' ');
        var asmOpcodes = lsASM.split(' ');
        if (asmTemplateOpcodes.length > asmOpcodes.length) {
            throw new Error("the raw script cannot match the asm template of contract " + contractName);
        }
        asmTemplateOpcodes.forEach(function (opcode, index) {
            if (opcode.startsWith('$')) {
                opcodesMap.set(opcode, asmOpcodes[index]);
            }
            else if (utils_1.bsv.Script.fromASM(opcode).toHex() !== utils_1.bsv.Script.fromASM(asmOpcodes[index]).toHex()) {
                throw new Error("the raw script cannot match the asm template of contract " + contractName);
            }
        });
        if (asmTemplateOpcodes.length < asmOpcodes.length) {
            var opcode = asmOpcodes[asmTemplateOpcodes.length];
            if (opcode !== 'OP_RETURN') {
                throw new Error("the raw script cannot match the asm template of contract " + contractName);
            }
        }
        var args = [];
        cParams.map(function (p) { return ({
            name: p.name,
            type: _this.finalTypeResolver(p.type)
        }); }).forEach(function (param) {
            if (utils_1.isStructType(param.type)) {
                var stclass = contract.getTypeClassByType(utils_1.getStructNameByType(param.type));
                args.push(utils_1.createStruct(contract, stclass, param.name, opcodesMap, _this.finalTypeResolver));
            }
            else if (utils_1.isArrayType(param.type)) {
                args.push(utils_1.createArray(contract, param.type, param.name, opcodesMap, _this.finalTypeResolver));
            }
            else {
                args.push(utils_1.asm2ScryptType(param.type, opcodesMap.get("$" + param.name)));
            }
        });
        return new FunctionCall('constructor', args, { contract: contract, lockingScriptASM: lsASM });
    };
    ABICoder.prototype.encodePubFunctionCall = function (contract, name, args) {
        var e_1, _a;
        var _this = this;
        try {
            for (var _b = __values(this.abi), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entity = _c.value;
                if (entity.name === name) {
                    if (entity.params.length !== args.length) {
                        throw new Error("wrong number of arguments for #" + name + ", expected " + entity.params.length + " but got " + args.length);
                    }
                    var asm = this.encodeParams(args, entity.params.map(function (p) { return ({
                        name: p.name,
                        type: _this.finalTypeResolver(p.type)
                    }); }));
                    if (this.abi.length > 2 && entity.index !== undefined) {
                        // selector when there are multiple public functions
                        var pubFuncIndex = entity.index;
                        asm += " " + utils_1.int2Asm(pubFuncIndex.toString());
                    }
                    return new FunctionCall(name, args, { contract: contract, unlockingScriptASM: asm });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new Error("no function named '" + name + "' found in abi");
    };
    ABICoder.prototype.encodeParams = function (args, paramsEntitys) {
        var _this = this;
        return args.map(function (arg, i) { return _this.encodeParam(arg, paramsEntitys[i]); }).join(' ');
    };
    ABICoder.prototype.encodeParamArray = function (args, arrayParm) {
        var _this = this;
        if (args.length === 0) {
            throw new Error('Empty array not allowed');
        }
        var t = typeof args[0];
        if (!args.every(function (arg) { return typeof arg === t; })) {
            throw new Error('Array arguments are not of the same type');
        }
        var _a = __read(utils_1.arrayTypeAndSize(arrayParm.type), 2), elemTypeName = _a[0], arraySizes = _a[1];
        if (utils_1.checkArray(args, [elemTypeName, arraySizes])) {
            return utils_1.flatternArray(args, arrayParm.name, arrayParm.type).map(function (arg) {
                return _this.encodeParam(arg.value, { name: arg.name, type: _this.finalTypeResolver(arg.type) });
            }).join(' ');
        }
        else {
            throw new Error("checkArray " + arrayParm.type + " fail");
        }
    };
    ABICoder.prototype.encodeParam = function (arg, paramEntity) {
        if (utils_1.isArrayType(paramEntity.type)) {
            if (Array.isArray(arg)) {
                return this.encodeParamArray(arg, paramEntity);
            }
            else {
                var scryptType_1 = utils_1.typeOfArg(arg);
                throw new Error("expect param " + paramEntity.name + " as " + paramEntity.type + " but got " + scryptType_1);
            }
        }
        if (utils_1.isStructType(paramEntity.type)) {
            if (scryptTypes_1.Struct.isStruct(arg)) {
                var argS = arg;
                if (paramEntity.type != argS.finalType) {
                    throw new Error("expect struct " + utils_1.getStructNameByType(paramEntity.type) + " but got struct " + argS.type);
                }
            }
            else {
                var scryptType_2 = arg.type;
                throw new Error("expect param " + paramEntity.name + " as struct " + utils_1.getStructNameByType(paramEntity.type) + " but got " + scryptType_2);
            }
        }
        var scryptType = utils_1.typeOfArg(arg);
        if (scryptType != paramEntity.type) {
            throw new Error("wrong argument type, expected " + paramEntity.type + " but got " + scryptType);
        }
        var typeofArg = typeof arg;
        if (typeofArg === 'boolean') {
            arg = new scryptTypes_1.Bool(arg);
        }
        if (typeofArg === 'number') {
            arg = new scryptTypes_1.Int(arg);
        }
        if (typeofArg === 'bigint') {
            arg = new scryptTypes_1.Int(arg);
        }
        if (typeof arg === 'string') {
            arg = new scryptTypes_1.Int(arg);
        }
        return arg.toASM();
    };
    return ABICoder;
}());
exports.ABICoder = ABICoder;
//# sourceMappingURL=abi.js.map