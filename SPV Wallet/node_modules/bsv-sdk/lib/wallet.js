"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bsv = __importStar(require("@sensible-contract/bsv"));
const showpay_providers_1 = require("showpay-providers");
const Txutils_1 = require("./utils/Txutils");
class Wallet {
    constructor(wif, network, metasvAuth, feeb = 0.5) {
        this.privateKey = bsv.PrivateKey.fromWIF(wif);
        this.publicKey = this.privateKey.publicKey;
        this.address = this.privateKey.toAddress(network);
        this.provider = new showpay_providers_1.MetaSVProvider(network, metasvAuth);
        this.feeb = feeb;
    }
    transfer(receivers, broadcast = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const balanceResp = yield this.provider.getBalance(this.address.toString());
            const addressBalance = balanceResp.balance + balanceResp.pendingBalance;
            let totalTransferAmount = 0;
            for (let receiver of receivers) {
                totalTransferAmount += receiver.amount;
            }
            if (addressBalance < totalTransferAmount) {
                throw new Error("Insufficient BSV Balance");
            }
            let utxos = yield this.getAddressUtxos(this.address.toString());
            const utxosAndFee = (0, Txutils_1.getTransferNeedUtxosAndFee)(receivers, utxos, this.feeb);
            utxos = utxosAndFee.utxos;
            const fee = utxosAndFee.fee;
            const tx = new bsv.Transaction();
            tx.from(utxos.map((utxo) => ({
                txId: utxo.txId,
                outputIndex: utxo.outputIndex,
                satoshis: utxo.satoshis,
                script: bsv.Script.buildPublicKeyHashOut(this.address).toHex()
            })));
            for (let receiver of receivers) {
                tx.addOutput(new bsv.Transaction.Output({
                    satoshis: receiver.amount,
                    script: bsv.Script.fromAddress(receiver.address)
                }));
            }
            let utxoTotalAmount = 0;
            utxos.forEach((utxo) => {
                utxoTotalAmount += utxo.satoshis;
            });
            if (utxoTotalAmount - fee - totalTransferAmount >= 135) {
                tx.addOutput(new bsv.Transaction.Output({
                    satoshis: utxoTotalAmount - fee - totalTransferAmount,
                    script: bsv.Script.fromAddress(this.address)
                }));
            }
            tx.fee(fee);
            tx.sign(this.privateKey);
            const txid = tx.id;
            const txHex = tx.serialize(true);
            let retUtxos = [];
            for (let i = 0; i < tx.outputs.length; i++) {
                retUtxos.push({
                    txId: txid,
                    outputIndex: i,
                    satoshis: tx.outputs[i].satoshis,
                    // @ts-ignore
                    address: bsv.Address.fromScript(tx.outputs[i].script).toString()
                });
            }
            if (broadcast) {
                const resTxid = yield this.provider.broadcast(txHex);
                if (!resTxid) {
                    throw new Error("broadcast error");
                }
            }
            return {
                txid,
                txHex,
                utxos: retUtxos
            };
        });
    }
    transferAll(receiverAddress, broadcast) {
        return __awaiter(this, void 0, void 0, function* () {
            const balanceResp = yield this.provider.getBalance(this.address.toString());
            const addressBalance = balanceResp.balance + balanceResp.pendingBalance;
            const utxos = yield this.getAddressUtxos(this.address.toString());
            const fee = Math.ceil((utxos.length * 148 + 34 + 10) * this.feeb);
            const minAmountCanTransfer = 135 + fee;
            if (addressBalance < minAmountCanTransfer) {
                throw new Error("Insufficient BSV Balance");
            }
            const tx = new bsv.Transaction();
            tx.from(utxos.map((utxo) => ({
                txId: utxo.txId,
                outputIndex: utxo.outputIndex,
                satoshis: utxo.satoshis,
                script: bsv.Script.buildPublicKeyHashOut(this.address).toHex()
            })));
            tx.addOutput(new bsv.Transaction.Output({
                satoshis: addressBalance - fee,
                script: bsv.Script.fromAddress(receiverAddress)
            }));
            tx.fee(fee);
            tx.sign(this.privateKey);
            const txid = tx.id;
            const txHex = tx.serialize(true);
            const retUtxos = [{
                    txId: txid,
                    outputIndex: 0,
                    satoshis: addressBalance - fee,
                    address: receiverAddress
                }];
            if (broadcast) {
                const resTxid = yield this.provider.broadcast(txHex);
                if (!resTxid) {
                    throw new Error("broadcast error");
                }
            }
            return {
                txid,
                txHex,
                utxos: retUtxos
            };
        });
    }
    getAddressUtxos(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxos = [];
            let flag = "";
            let gUtxos = [];
            for (let i = 0; i < 10; i++) {
                gUtxos = yield this.provider.getUtxos(address, { flag });
                if (gUtxos.length == 0) {
                    break;
                }
                flag = gUtxos[gUtxos.length - 1].flag;
                utxos = utxos.concat(gUtxos);
            }
            return utxos;
        });
    }
}
exports.default = Wallet;
