"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveStaticConst = exports.isInteger = exports.toLiteral = exports.createArray = exports.createStruct = exports.stripAnsi = exports.ansiRegex = exports.resolveType = exports.genLaunchConfigFile = exports.newCall = exports.compileContract = exports.getCIScryptc = exports.isEmpty = exports.readFileByLine = exports.typeOfArg = exports.flatternStruct = exports.flatternArray = exports.subscript = exports.checkArray = exports.subArrayType = exports.toLiteralArrayType = exports.arrayTypeAndSize = exports.arrayTypeAndSizeStr = exports.checkStruct = exports.findStructByType = exports.getStructNameByType = exports.isArrayType = exports.isStructType = exports.findStructByName = exports.literal2Asm = exports.uri2path = exports.path2uri = exports.isNode = exports.bin2num = exports.num2bin = exports.getPreimage = exports.toHex = exports.signTx = exports.getValidatedHexString = exports.hexStringToBytes = exports.bytesToHexString = exports.bytes2Literal = exports.asm2ScryptType = exports.literal2ScryptType = exports.parseLiteral = exports.intValue2hex = exports.int2Value = exports.asm2int = exports.int2Asm = exports.bool2Asm = exports.DEFAULT_SIGHASH_TYPE = exports.DEFAULT_FLAGS = exports.ECIES = exports.bsv = void 0;
var url_1 = require("url");
var scryptTypes_1 = require("./scryptTypes");
var compilerWrapper_1 = require("./compilerWrapper");
var bsv = require("bsv");
exports.bsv = bsv;
var ECIES = require("bsv/ecies");
exports.ECIES = ECIES;
var fs = require("fs");
var path_1 = require("path");
var minimist = require("minimist");
var os_1 = require("os");
var BN = bsv.crypto.BN;
var Interp = bsv.Script.Interpreter;
exports.DEFAULT_FLAGS = 
//Interp.SCRIPT_VERIFY_P2SH | Interp.SCRIPT_VERIFY_CLEANSTACK | // no longer applies now p2sh is deprecated: cleanstack only applies to p2sh
Interp.SCRIPT_ENABLE_MAGNETIC_OPCODES | Interp.SCRIPT_ENABLE_MONOLITH_OPCODES | // TODO: to be removed after upgrade to bsv 2.0
    Interp.SCRIPT_VERIFY_STRICTENC |
    Interp.SCRIPT_ENABLE_SIGHASH_FORKID | Interp.SCRIPT_VERIFY_LOW_S | Interp.SCRIPT_VERIFY_NULLFAIL |
    Interp.SCRIPT_VERIFY_DERSIG |
    Interp.SCRIPT_VERIFY_MINIMALDATA | Interp.SCRIPT_VERIFY_NULLDUMMY |
    Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |
    Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY | Interp.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;
exports.DEFAULT_SIGHASH_TYPE = bsv.crypto.Signature.SIGHASH_ALL | bsv.crypto.Signature.SIGHASH_FORKID;
function bool2Asm(str) {
    if (str === 'true') {
        return 'OP_TRUE';
    }
    if (str === 'false') {
        return 'OP_FALSE';
    }
    throw new Error("invalid str '" + str + "' to convert to bool");
}
exports.bool2Asm = bool2Asm;
/**
 * decimal or hex int to little-endian signed magnitude
 */
function int2Asm(str) {
    if (/^(-?\d+)$/.test(str) || /^0x([0-9a-fA-F]+)$/.test(str)) {
        var number = str.startsWith('0x') ? new BN(str.substring(2), 16) : new BN(str, 10);
        if (number.eqn(-1)) {
            return 'OP_1NEGATE';
        }
        if (number.gten(0) && number.lten(16)) {
            return 'OP_' + str;
        }
        var m = number.toSM({ endian: 'little' });
        return m.toString('hex');
    }
    else {
        throw new Error("invalid str '" + str + "' to convert to int");
    }
}
exports.int2Asm = int2Asm;
/**
 * convert asm string to number or bigint
 */
function asm2int(str) {
    switch (str) {
        case 'OP_1NEGATE':
            return -1;
        case '0':
        case 'OP_0':
        case 'OP_1':
        case 'OP_2':
        case 'OP_3':
        case 'OP_4':
        case 'OP_5':
        case 'OP_6':
        case 'OP_7':
        case 'OP_8':
        case 'OP_9':
        case 'OP_10':
        case 'OP_11':
        case 'OP_12':
        case 'OP_13':
        case 'OP_14':
        case 'OP_15':
        case 'OP_16':
            return parseInt(str.replace('OP_', ''));
        default: {
            var value = getValidatedHexString(str);
            var bn = BN.fromHex(value, {
                endian: 'little'
            });
            if (bn.toNumber() < Number.MAX_SAFE_INTEGER && bn.toNumber() > Number.MIN_SAFE_INTEGER) {
                return bn.toNumber();
            }
            else if (typeof BigInt === 'function') {
                return BigInt(bn.toString());
            }
            else {
                return bn.toString();
            }
        }
    }
}
exports.asm2int = asm2int;
/**
 * decimal int or hex str to number or bigint
 */
function int2Value(str) {
    if (/^(-?\d+)$/.test(str) || /^0x([0-9a-fA-F]+)$/.test(str)) {
        var bn = str.startsWith('0x') ? new BN(str.substring(2), 16) : new BN(str, 10);
        if (bn.toNumber() < Number.MAX_SAFE_INTEGER && bn.toNumber() > Number.MIN_SAFE_INTEGER) {
            return bn.toNumber();
        }
        else if (typeof BigInt === 'function') {
            return BigInt(bn.toString());
        }
        else {
            return bn.toString();
        }
    }
    else {
        throw new Error("invalid str '" + str + "' to convert to int");
    }
}
exports.int2Value = int2Value;
function intValue2hex(val) {
    var hex = val.toString(16);
    if (hex.length % 2 === 1) {
        hex = '0' + hex;
    }
    return hex;
}
exports.intValue2hex = intValue2hex;
function parseLiteral(l) {
    // bool
    if (l === 'false') {
        return ['OP_FALSE', false, scryptTypes_1.VariableType.BOOL];
    }
    if (l === 'true') {
        return ['OP_TRUE', true, scryptTypes_1.VariableType.BOOL];
    }
    // hex int
    var m = /^(0x[0-9a-fA-F]+)$/.exec(l);
    if (m) {
        return [int2Asm(m[1]), int2Value(m[1]), scryptTypes_1.VariableType.INT];
    }
    // decimal int
    m = /^(-?\d+)$/.exec(l);
    if (m) {
        return [int2Asm(m[1]), int2Value(m[1]), scryptTypes_1.VariableType.INT];
    }
    // bytes
    // note: special handling of empty bytes b''
    m = /^b'([\da-fA-F]*)'$/.exec(l);
    if (m) {
        var hexString = getValidatedHexString(m[1]);
        if (hexString === '') {
            return ['OP_0', hexString, scryptTypes_1.VariableType.BYTES];
        }
        if (hexString.length / 2 > 1) {
            return [hexString, hexString, scryptTypes_1.VariableType.BYTES];
        }
        var intValue = parseInt(hexString, 16);
        if (intValue >= 1 && intValue <= 16) {
            return ["OP_" + intValue, hexString, scryptTypes_1.VariableType.BYTES];
        }
        return [hexString, hexString, scryptTypes_1.VariableType.BYTES];
    }
    // PrivKey
    // 1) decimal int
    m = /^PrivKey\((-?\d+)\)$/.exec(l);
    if (m) {
        return [int2Asm(m[1]), int2Value(m[1]), scryptTypes_1.VariableType.PRIVKEY];
    }
    // 2) hex int
    m = /^PrivKey\((0x[0-9a-fA-F]+)\)$/.exec(l);
    if (m) {
        return [int2Asm(m[1]), int2Value(m[1]), scryptTypes_1.VariableType.PRIVKEY];
    }
    // PubKey
    m = /^PubKey\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.PUBKEY];
    }
    // Sig
    m = /^Sig\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.SIG];
    }
    // Ripemd160
    m = /^Ripemd160\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.RIPEMD160];
    }
    // Sha1
    m = /^Sha1\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.SHA1];
    }
    // Sha256
    m = /^Sha256\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.SHA256];
    }
    // SigHashType
    m = /^SigHashType\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var bn = new BN(getValidatedHexString(m[1]), 16);
        return [bn.toString('hex', 2), bn.toNumber(), scryptTypes_1.VariableType.SIGHASHTYPE];
    }
    // SigHashPreimage
    m = /^SigHashPreimage\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.SIGHASHPREIMAGE];
    }
    // OpCodeType
    m = /^OpCodeType\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = getValidatedHexString(m[1]);
        return [value, value, scryptTypes_1.VariableType.OPCODETYPE];
    }
    // Struct
    m = /^\{([\w(){}[\],\s'-]+)\}$/.exec(l);
    if (m) {
        // we use object to constructor a struct, no use literal, so here we return empty
        return ['', '', scryptTypes_1.VariableType.STRUCT];
    }
    throw new Error("<" + l + "> cannot be cast to ASM format, only sCrypt native types supported");
}
exports.parseLiteral = parseLiteral;
/**
 * convert literals to Scrypt Type
 */
function literal2ScryptType(l) {
    var _a = __read(parseLiteral(l), 3), asm = _a[0], value = _a[1], type = _a[2];
    switch (type) {
        case scryptTypes_1.VariableType.BOOL:
            return new scryptTypes_1.Bool(value);
        case scryptTypes_1.VariableType.INT:
            return new scryptTypes_1.Int(value);
        case scryptTypes_1.VariableType.BYTES:
            return new scryptTypes_1.Bytes(value);
        case scryptTypes_1.VariableType.PRIVKEY:
            return new scryptTypes_1.PrivKey(value);
        case scryptTypes_1.VariableType.PUBKEY:
            return new scryptTypes_1.PubKey(value);
        case scryptTypes_1.VariableType.SIG:
            return new scryptTypes_1.Sig(value);
        case scryptTypes_1.VariableType.RIPEMD160:
            return new scryptTypes_1.Ripemd160(value);
        case scryptTypes_1.VariableType.SHA1:
            return new scryptTypes_1.Sha1(value);
        case scryptTypes_1.VariableType.SHA256:
            return new scryptTypes_1.Sha256(value);
        case scryptTypes_1.VariableType.SIGHASHTYPE:
            return new scryptTypes_1.SigHashType(value);
        case scryptTypes_1.VariableType.SIGHASHPREIMAGE:
            return new scryptTypes_1.SigHashPreimage(value);
        case scryptTypes_1.VariableType.OPCODETYPE:
            return new scryptTypes_1.OpCodeType(value);
        default:
            throw new Error("<" + l + "> cannot be cast to ScryptType, only sCrypt native types supported");
    }
}
exports.literal2ScryptType = literal2ScryptType;
function asm2ScryptType(type, asm) {
    switch (type) {
        case scryptTypes_1.VariableType.BOOL:
            return new scryptTypes_1.Bool(BN.fromString(asm) > 0 ? true : false);
        case scryptTypes_1.VariableType.INT:
            return new scryptTypes_1.Int(asm2int(asm));
        case scryptTypes_1.VariableType.BYTES:
            return new scryptTypes_1.Bytes(asm);
        case scryptTypes_1.VariableType.PRIVKEY:
            return new scryptTypes_1.PrivKey(asm2int(asm));
        case scryptTypes_1.VariableType.PUBKEY:
            return new scryptTypes_1.PubKey(asm);
        case scryptTypes_1.VariableType.SIG:
            return new scryptTypes_1.Sig(asm);
        case scryptTypes_1.VariableType.RIPEMD160:
            return new scryptTypes_1.Ripemd160(asm);
        case scryptTypes_1.VariableType.SHA1:
            return new scryptTypes_1.Sha1(asm);
        case scryptTypes_1.VariableType.SHA256:
            return new scryptTypes_1.Sha256(asm);
        case scryptTypes_1.VariableType.SIGHASHTYPE:
            return new scryptTypes_1.SigHashType(asm2int(asm));
        case scryptTypes_1.VariableType.SIGHASHPREIMAGE:
            return new scryptTypes_1.SigHashPreimage(asm);
        case scryptTypes_1.VariableType.OPCODETYPE:
            return new scryptTypes_1.OpCodeType(asm);
        default:
            throw new Error("<" + type + "> cannot be cast to ScryptType, only sCrypt native types supported");
    }
}
exports.asm2ScryptType = asm2ScryptType;
function bytes2Literal(bytearray, type) {
    switch (type) {
        case 'bool':
            return BN.fromBuffer(bytearray, { endian: 'little' }) > 0 ? 'true' : 'false';
        case 'int':
        case 'PrivKey':
            return BN.fromSM(bytearray, { endian: 'little' }).toString();
        case 'bytes':
            return "b'" + bytesToHexString(bytearray) + "'";
        default:
            return "b'" + bytesToHexString(bytearray) + "'";
    }
}
exports.bytes2Literal = bytes2Literal;
function bytesToHexString(bytearray) {
    return bytearray.reduce(function (o, c) { return o += ('0' + (c & 0xFF).toString(16)).slice(-2); }, '');
}
exports.bytesToHexString = bytesToHexString;
function hexStringToBytes(hex) {
    getValidatedHexString(hex);
    return hex.split('')
        .reduce(function (o, c, i) {
        if (i % 2 === 0) {
            o.push(c);
        }
        else {
            o[o.length - 1] += c;
        }
        return o;
    }, new Array())
        .map(function (b) { return parseInt(b, 16); });
}
exports.hexStringToBytes = hexStringToBytes;
function getValidatedHexString(hex, allowEmpty) {
    if (allowEmpty === void 0) { allowEmpty = true; }
    var ret = hex.trim();
    if (ret.length < 1 && !allowEmpty) {
        throw new Error('can\'t be empty string');
    }
    if (ret.length % 2) {
        throw new Error(ret + " should have even length");
    }
    if (ret.length > 0 && !(/^[\da-f]+$/i.test(ret))) {
        throw new Error(ret + " should only contain [0-9] or characters [a-fA-F]");
    }
    return ret;
}
exports.getValidatedHexString = getValidatedHexString;
function signTx(tx, privateKey, lockingScriptASM, inputAmount, inputIndex, sighashType, flags) {
    if (inputIndex === void 0) { inputIndex = 0; }
    if (sighashType === void 0) { sighashType = exports.DEFAULT_SIGHASH_TYPE; }
    if (flags === void 0) { flags = exports.DEFAULT_FLAGS; }
    if (!tx) {
        throw new Error('param tx can not be empty');
    }
    if (!privateKey) {
        throw new Error('param privateKey can not be empty');
    }
    if (!lockingScriptASM) {
        throw new Error('param lockingScriptASM can not be empty');
    }
    if (!inputAmount) {
        throw new Error('param inputAmount can not be empty');
    }
    return bsv.Transaction.sighash.sign(tx, privateKey, sighashType, inputIndex, bsv.Script.fromASM(lockingScriptASM), new bsv.crypto.BN(inputAmount), flags).toTxFormat();
}
exports.signTx = signTx;
function toHex(x) {
    return x.toString('hex');
}
exports.toHex = toHex;
function getPreimage(tx, inputLockingScriptASM, inputAmount, inputIndex, sighashType, flags) {
    if (inputIndex === void 0) { inputIndex = 0; }
    if (sighashType === void 0) { sighashType = exports.DEFAULT_SIGHASH_TYPE; }
    if (flags === void 0) { flags = exports.DEFAULT_FLAGS; }
    var preimageBuf = bsv.Transaction.sighash.sighashPreimage(tx, sighashType, inputIndex, bsv.Script.fromASM(inputLockingScriptASM), new bsv.crypto.BN(inputAmount), flags);
    return new scryptTypes_1.SigHashPreimage(preimageBuf.toString('hex'));
}
exports.getPreimage = getPreimage;
// Converts a number into a sign-magnitude representation of certain size as a string
// Throws if the number cannot be accommodated
// Often used to append numbers to OP_RETURN, which are read in contracts
// Support Bigint
function num2bin(n, dataLen) {
    var num = new BN(n);
    if (num.eqn(0)) {
        return '00'.repeat(dataLen);
    }
    var s = num.toSM({ endian: 'little' }).toString('hex');
    var byteLen_ = s.length / 2;
    if (byteLen_ > dataLen) {
        throw new Error(n + " cannot fit in " + dataLen + " byte[s]");
    }
    if (byteLen_ === dataLen) {
        return s;
    }
    var paddingLen = dataLen - byteLen_;
    var lastByte = s.substring(s.length - 2);
    var rest = s.substring(0, s.length - 2);
    var m = parseInt(lastByte, 16);
    if (num.isNeg) {
        // reset sign bit
        m &= 0x7F;
    }
    var mHex = m.toString(16);
    if (mHex.length < 2) {
        mHex = '0' + mHex;
    }
    var padding = n > 0 ? '00'.repeat(paddingLen) : '00'.repeat(paddingLen - 1) + '80';
    return rest + mHex + padding;
}
exports.num2bin = num2bin;
//Support Bigint
function bin2num(s) {
    var hex = s.toString('hex');
    var lastByte = hex.substring(hex.length - 2);
    var rest = hex.substring(0, hex.length - 2);
    var m = parseInt(lastByte, 16);
    var n = m & 0x7F;
    var nHex = n.toString(16);
    if (nHex.length < 2) {
        nHex = '0' + nHex;
    }
    //Support negative number
    var bn = BN.fromHex(rest + nHex, { endian: 'little' });
    if (m >> 7) {
        bn = bn.neg();
    }
    if (typeof BigInt === 'function') {
        return BigInt(bn);
    }
    else if (bn.toNumber() < Number.MAX_SAFE_INTEGER && bn.toNumber() > Number.MIN_SAFE_INTEGER) {
        return bn.toNumber();
    }
    else {
        return bn.toString();
    }
}
exports.bin2num = bin2num;
function isNode() {
    return typeof window === 'undefined' && typeof process === 'object';
}
exports.isNode = isNode;
function path2uri(path) {
    if (isNode()) {
        return url_1.pathToFileURL(path).toString();
    }
    else {
        return path;
    }
}
exports.path2uri = path2uri;
function uri2path(uri) {
    if (isNode()) {
        return url_1.fileURLToPath(uri);
    }
    else {
        return uri;
    }
}
exports.uri2path = uri2path;
/**
 * @deprecated
 * convert literals to script ASM format
 */
function literal2Asm(l) {
    var _a = __read(parseLiteral(l), 3), asm = _a[0], _ = _a[1], type = _a[2];
    return [asm, type];
}
exports.literal2Asm = literal2Asm;
function findStructByName(name, s) {
    return s.find(function (s) {
        return s.name == name;
    });
}
exports.findStructByName = findStructByName;
function isStructType(type) {
    return /^struct\s(\w+)\s\{\}$/.test(type);
}
exports.isStructType = isStructType;
// test struct Token {}[3], int[3], st.b.c[3]
function isArrayType(type) {
    return /^\w[\w.\s{}]+(\[[\w.]+\])+$/.test(type);
}
exports.isArrayType = isArrayType;
function getStructNameByType(type) {
    var m = /^struct\s(\w+)\s\{\}$/.exec(type.trim());
    if (m) {
        return m[1];
    }
    return '';
}
exports.getStructNameByType = getStructNameByType;
function findStructByType(type, s) {
    var name = getStructNameByType(type);
    if (name) {
        return findStructByName(name, s);
    }
    return undefined;
}
exports.findStructByType = findStructByType;
function checkStruct(s, arg, typeResolver) {
    s.params.forEach(function (p) {
        var member = arg.memberByKey(p.name);
        var finalType = typeOfArg(member);
        var paramFinalType = typeResolver(p.type);
        if (finalType === 'undefined') {
            throw new Error("argument of type struct " + s.name + " missing member " + p.name);
        }
        else if (finalType != paramFinalType) {
            if (isArrayType(paramFinalType)) {
                var _a = __read(arrayTypeAndSize(paramFinalType), 2), elemTypeName = _a[0], arraySize = _a[1];
                if (Array.isArray(arg.value[p.name])) {
                    if (!checkArray(arg.value[p.name], [elemTypeName, arraySize])) {
                        throw new Error("checkArray fail, struct " + s.name + " property " + p.name + " should be " + paramFinalType);
                    }
                }
                else {
                    throw new Error("struct " + s.name + " property " + p.name + " should be " + paramFinalType);
                }
            }
            else {
                throw new Error("wrong argument type, expected " + paramFinalType + " but got " + finalType);
            }
        }
    });
    var members = s.params.map(function (p) { return p.name; });
    arg.getMembers().forEach(function (key) {
        if (!members.includes(key)) {
            throw new Error(key + " is not a member of struct " + s.name);
        }
    });
}
exports.checkStruct = checkStruct;
/**
 * return eg. int[N][N][4] => ['int', ["N","N","4"]]
 * @param arrayTypeName
 */
function arrayTypeAndSizeStr(arrayTypeName) {
    var arraySizes = [];
    __spread(arrayTypeName.matchAll(/\[([\w.]+)\]+/g)).map(function (match) {
        arraySizes.push(match[1]);
    });
    var group = arrayTypeName.split('[');
    var elemTypeName = group[0];
    return [elemTypeName, arraySizes];
}
exports.arrayTypeAndSizeStr = arrayTypeAndSizeStr;
/**
 * return eg. int[2][3][4] => ['int', [2,3,4]]
 * @param arrayTypeName  eg. int[2][3][4]
 */
function arrayTypeAndSize(arrayTypeName) {
    var _a = __read(arrayTypeAndSizeStr(arrayTypeName), 2), elemTypeName = _a[0], arraySizes = _a[1];
    return [elemTypeName, arraySizes.map(function (size) {
            var n = parseInt(size);
            if (isNaN(n)) {
                throw new Error("arrayTypeAndSize error type " + arrayTypeName + " with sub isNaN");
            }
            return n;
        })];
}
exports.arrayTypeAndSize = arrayTypeAndSize;
function toLiteralArrayType(elemTypeName, sizes) {
    return [elemTypeName, sizes.map(function (size) { return "[" + size + "]"; }).join('')].join('');
}
exports.toLiteralArrayType = toLiteralArrayType;
/**
 * return eg. int[2][3][4] => int[3][4]
 * @param arrayTypeName  eg. int[2][3][4]
 */
function subArrayType(arrayTypeName) {
    var _a = __read(arrayTypeAndSize(arrayTypeName), 2), elemTypeName = _a[0], sizes = _a[1];
    return toLiteralArrayType(elemTypeName, sizes.slice(1));
}
exports.subArrayType = subArrayType;
function checkArray(args, arrayInfo) {
    var _a = __read(arrayInfo, 2), elemTypeName = _a[0], arraySizes = _a[1];
    if (!Array.isArray(args)) {
        return false;
    }
    var len = arraySizes[0];
    if (!len) {
        return false;
    }
    if (args.length !== len) {
        return false;
    }
    if (!args.every(function (arg) {
        if (Array.isArray(arg)) {
            return checkArray(arg, [elemTypeName, arraySizes.slice(1)]);
        }
        else {
            var scryptType = typeOfArg(arg);
            return scryptType === elemTypeName && arraySizes.length == 1;
        }
    })) {
        return false;
    }
    return true;
}
exports.checkArray = checkArray;
function subscript(index, arraySizes) {
    if (arraySizes.length == 1) {
        return "[" + index + "]";
    }
    else if (arraySizes.length > 1) {
        var subArraySizes = arraySizes.slice(1);
        var offset = subArraySizes.reduce(function (acc, val) { return acc * val; }, 1);
        return "[" + Math.floor(index / offset) + "]" + subscript(index % offset, subArraySizes);
    }
}
exports.subscript = subscript;
function flatternArray(arg, name, finalType) {
    if (!Array.isArray(arg)) {
        throw new Error('flatternArray only work on array');
    }
    var _a = __read(arrayTypeAndSize(finalType), 2), elemTypeName = _a[0], arraySizes = _a[1];
    return arg.map(function (item, index) {
        if (typeof item === 'boolean') {
            item = new scryptTypes_1.Bool(item);
        }
        else if (typeof item === 'number') {
            item = new scryptTypes_1.Int(item);
        }
        else if (typeof item === 'bigint') {
            item = new scryptTypes_1.Int(item);
        }
        else if (Array.isArray(item)) {
            return flatternArray(item, name + "[" + index + "]", subArrayType(finalType));
        }
        else if (scryptTypes_1.Struct.isStruct(item)) {
            return flatternStruct(item, name + "[" + index + "]");
        }
        else {
            item = item;
        }
        return {
            value: item,
            name: "" + name + subscript(index, arraySizes),
            type: elemTypeName
        };
    }).flat(Infinity);
}
exports.flatternArray = flatternArray;
function flatternStruct(arg, name) {
    if (scryptTypes_1.Struct.isStruct(arg)) {
        var argS_1 = arg;
        var keys = argS_1.getMembers();
        return keys.map(function (key) {
            var member = argS_1.memberByKey(key);
            if (scryptTypes_1.Struct.isStruct(member)) {
                return flatternStruct(member, name + "." + key);
            }
            else if (Array.isArray(member)) {
                var finalType = argS_1.getMemberAstFinalType(key);
                return flatternArray(member, name + "." + key, finalType);
            }
            else {
                member = member;
                return {
                    value: member,
                    name: name + "." + key,
                    type: member.type
                };
            }
        }).flat(Infinity);
    }
    else {
        throw new Error(arg + " should be struct");
    }
}
exports.flatternStruct = flatternStruct;
function typeOfArg(arg) {
    if (arg instanceof scryptTypes_1.ScryptType) {
        var scryptType = arg.finalType;
        return scryptType;
    }
    var typeofArg = typeof arg;
    if (typeofArg === 'boolean') {
        return 'bool';
    }
    if (typeofArg === 'number') {
        return 'int';
    }
    if (typeofArg === 'bigint') {
        return 'int';
    }
    if (typeofArg === 'string') {
        return 'int';
    }
    return typeof arg;
}
exports.typeOfArg = typeOfArg;
function readFileByLine(path, index) {
    var result = '';
    fs.readFileSync(path, 'utf8').split(/\r?\n/).every(function (line, i) {
        if (i === (index - 1)) {
            result = line;
            return false;
        }
        return true;
    });
    return result;
}
exports.readFileByLine = readFileByLine;
function isEmpty(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
}
exports.isEmpty = isEmpty;
function findCompiler(directory) {
    if (!directory) {
        directory = path_1.dirname(module.parent.filename);
    }
    var compiler = path_1.resolve(directory, 'compiler');
    if (fs.existsSync(compiler) && fs.statSync(compiler).isDirectory()) {
        var scryptc = path_1.join(compiler, '..', compilerWrapper_1.getPlatformScryptc());
        return scryptc;
    }
    var parent = path_1.resolve(directory, '..');
    if (parent === directory) {
        return undefined;
    }
    return findCompiler(parent);
}
function getCIScryptc() {
    var scryptc = findCompiler(__dirname);
    return fs.existsSync(scryptc) ? scryptc : undefined;
}
exports.getCIScryptc = getCIScryptc;
function compileContract(file, options) {
    console.log("Compiling contract " + file + " ...");
    options = Object.assign({
        out: path_1.join(__dirname, '../out'),
        sourceMap: true
    }, options);
    if (!fs.existsSync(file)) {
        throw ("file " + file + " not exists!");
    }
    var argv = minimist(process.argv.slice(2));
    var scryptc = argv.scryptc;
    if (argv.ci || !scryptc) {
        scryptc = getCIScryptc();
    }
    var result = compilerWrapper_1.compile({ path: file }, {
        desc: true, debug: options.sourceMap, outputDir: options.out,
        cmdPrefix: scryptc
    });
    return result;
}
exports.compileContract = compileContract;
function newCall(Cls, args) {
    return new (Function.prototype.bind.apply(Cls, [null].concat(args)));
}
exports.newCall = newCall;
function genLaunchConfigFile(constructorArgs, pubFuncArgs, pubFunc, name, program, txContext, asmArgs) {
    // some desc without sourceMap will not have file property.
    if (!program) {
        return '';
    }
    var debugConfig = {
        type: 'scrypt',
        request: 'launch',
        internalConsoleOptions: 'openOnSessionStart',
        name: name,
        program: program,
        constructorArgs: constructorArgs,
        pubFunc: pubFunc,
        pubFuncArgs: pubFuncArgs
    };
    var debugTxContext = {};
    if (!isEmpty(txContext)) {
        var tx = txContext.tx || '';
        var inputIndex = txContext.inputIndex || 0;
        var inputSatoshis = txContext.inputSatoshis || 0;
        if (tx) {
            Object.assign(debugTxContext, { hex: tx.toString(), inputIndex: inputIndex, inputSatoshis: inputSatoshis });
        }
        if (typeof txContext.opReturn === 'string') {
            Object.assign(debugTxContext, { opReturn: txContext.opReturn });
        }
    }
    if (!isEmpty(asmArgs)) {
        Object.assign(debugConfig, { asmArgs: asmArgs });
    }
    if (!isEmpty(debugTxContext)) {
        Object.assign(debugConfig, { txContext: debugTxContext });
    }
    var launch = {
        version: '0.2.0',
        configurations: [debugConfig]
    };
    var jsonstr = JSON.stringify(launch, function (key, value) { return (typeof value === 'bigint'
        ? value.toString()
        : value // return everything else unchanged
    ); }, 2);
    if (isNode()) {
        var filename = name + "-launch.json";
        var file = path_1.join(fs.mkdtempSync("" + os_1.tmpdir() + path_1.sep + "sCrypt."), filename);
        fs.writeFileSync(file, jsonstr);
        return path2uri(file);
    }
    else {
        console.error(pubFunc + "() call fail, see launch.json", jsonstr);
    }
}
exports.genLaunchConfigFile = genLaunchConfigFile;
/***
 * resolve type
 */
function resolveType(alias, type) {
    if (isArrayType(type)) {
        var _a = __read(arrayTypeAndSizeStr(type), 2), elemTypeName = _a[0], sizes = _a[1];
        var elemType = resolveType(alias, elemTypeName);
        if (isArrayType(elemType)) {
            var _b = __read(arrayTypeAndSizeStr(elemType), 2), elemTypeName_ = _b[0], sizes_ = _b[1];
            return toLiteralArrayType(elemTypeName_, sizes.concat(sizes_));
        }
        return toLiteralArrayType(resolveType(alias, elemTypeName), sizes);
    }
    if (isStructType(type)) {
        return resolveType(alias, getStructNameByType(type));
    }
    var a = alias.find(function (a) {
        return a.name === type;
    });
    if (a) {
        return resolveType(alias, a.type);
    }
    else {
        if (scryptTypes_1.BasicType.indexOf(type) > -1) {
            return type;
        }
        else { // should be struct if it is not basic type
            return "struct " + type + " {}";
        }
    }
}
exports.resolveType = resolveType;
function ansiRegex(_a) {
    var _b = (_a === void 0 ? {} : _a).onlyFirst, onlyFirst = _b === void 0 ? false : _b;
    var pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
exports.ansiRegex = ansiRegex;
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError("Expected a `string`, got `" + typeof string + "`");
    }
    return string.replace(ansiRegex(), '');
}
exports.stripAnsi = stripAnsi;
function createStruct(contract, sType, name, opcodesMap, finalTypeResolver) {
    var obj = Object.create({});
    sType.structAst.params.forEach(function (param) {
        var _a, _b, _c;
        var finalType = finalTypeResolver(param.type);
        if (isStructType(finalType)) {
            var stclass = contract.getTypeClassByType(param.type);
            Object.assign(obj, (_a = {},
                _a[param.name] = createStruct(contract, stclass, name + "." + param.name, opcodesMap, finalTypeResolver),
                _a));
        }
        else if (isArrayType(finalType)) {
            Object.assign(obj, (_b = {},
                _b[param.name] = createArray(contract, finalType, name + "." + param.name, opcodesMap, finalTypeResolver),
                _b));
        }
        else {
            Object.assign(obj, (_c = {},
                _c[param.name] = asm2ScryptType(finalType, opcodesMap.get("$" + name + "." + param.name)),
                _c));
        }
    });
    return new sType(obj);
}
exports.createStruct = createStruct;
function createArray(contract, type, name, opcodesMap, finalTypeResolver) {
    var arrays = [];
    var _a = __read(arrayTypeAndSize(type), 2), elemTypeName = _a[0], sizes = _a[1];
    var arraylen = sizes[0];
    if (sizes.length === 1) {
        for (var index = 0; index < arraylen; index++) {
            var finalType = finalTypeResolver(elemTypeName);
            if (isStructType(finalType)) {
                var stclass = contract.getTypeClassByType(finalType);
                arrays.push(createStruct(contract, stclass, name + "[" + index + "]", opcodesMap, finalTypeResolver));
            }
            else {
                arrays.push(asm2ScryptType(finalType, opcodesMap.get("$" + name + "[" + index + "]")));
            }
        }
    }
    else {
        for (var index = 0; index < arraylen; index++) {
            var finalType = finalTypeResolver(elemTypeName);
            var subArrayType_1 = [finalType, sizes.slice(1).map(function (size) { return "[" + size + "]"; }).join('')].join('');
            arrays.push(createArray(contract, subArrayType_1, name + "[" + index + "]", opcodesMap, finalTypeResolver));
        }
    }
    return arrays;
}
exports.createArray = createArray;
function toLiteral(value) {
    if (Array.isArray(value)) {
        return "[" + value.map(function (i) { return toLiteral(i); }) + "]";
    }
    else {
        return value instanceof scryptTypes_1.ScryptType ? value.toLiteral() : value;
    }
}
exports.toLiteral = toLiteral;
function isInteger(x) {
    // check if the passed value is a number
    if (typeof x == 'number' && !isNaN(x)) {
        // check if it is integer
        return Number.isInteger(x);
    }
    else if (typeof x == 'bigint') {
        return true;
    }
    else if (typeof x == 'string') {
        // hex int
        var m = /^(0x[0-9a-fA-F]+)$/.exec(x);
        if (m) {
            return true;
        }
        // decimal int
        m = /^(-?\d+)$/.exec(x);
        if (m) {
            return true;
        }
        return false;
    }
    return false;
}
exports.isInteger = isInteger;
function resolveStaticConst(contract, type, staticConstInt) {
    if (isArrayType(type)) {
        var _a = __read(arrayTypeAndSizeStr(type), 2), elemTypeName = _a[0], arraySizes = _a[1];
        var sizes = arraySizes.map(function (size) {
            if (/^(\d)+$/.test(size)) {
                return parseInt(size);
            }
            else {
                var value = (size.indexOf('.') > 0) ? staticConstInt[size] : staticConstInt[contract + "." + size];
                if (!value) {
                    console.warn("resolve array sub " + size + " fail");
                    return size;
                }
                return value;
            }
        });
        return toLiteralArrayType(elemTypeName, sizes);
    }
    return type;
}
exports.resolveStaticConst = resolveStaticConst;
//# sourceMappingURL=utils.js.map