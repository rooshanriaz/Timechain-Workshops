"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicScryptType = exports.BasicType = exports.VariableType = exports.Struct = exports.OpCodeType = exports.SigHashPreimage = exports.SigHashType = exports.SigHash = exports.Sha256 = exports.Sha1 = exports.Ripemd160 = exports.Sig = exports.PubKey = exports.PrivKey = exports.Bytes = exports.Bool = exports.Int = exports.ScryptType = exports.toScryptType = void 0;
var utils_1 = require("./utils");
var bsv = require("bsv");
function toScryptType(a) {
    if (typeof a === 'number' || typeof a === 'bigint' || typeof a === 'string') {
        return new Int(a);
    }
    else if (typeof a === 'boolean') {
        return new Bool(a);
    }
    else if (a instanceof ScryptType) {
        return a;
    }
    else {
        throw a + " cannot be convert to ScryptType";
    }
}
exports.toScryptType = toScryptType;
var ScryptType = /** @class */ (function () {
    function ScryptType(value) {
        try {
            this._value = this.checkValue(value);
            this._literal = this.toLiteral();
            var _a = __read(utils_1.parseLiteral(this._literal), 3), asm = _a[0], _ = _a[1], scrType = _a[2];
            this._type = scrType;
            this._asm = asm;
        }
        catch (error) {
            throw new Error("can't construct " + this.constructor.name + " from <" + value + ">, " + error.message);
        }
    }
    Object.defineProperty(ScryptType.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScryptType.prototype, "finalType", {
        get: function () {
            if (this._typeResolver)
                return this._typeResolver(this.type);
            return this.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScryptType.prototype, "literal", {
        get: function () {
            return this._literal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScryptType.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: false,
        configurable: true
    });
    ScryptType.prototype.toASM = function () {
        return this._asm;
    };
    ScryptType.prototype.toJSON = function () {
        return this.toLiteral();
    };
    ScryptType.prototype.toLiteral = function () {
        return '';
    };
    ScryptType.prototype.checkValue = function (value) {
        if (typeof value === 'undefined') {
            throw new Error('constructor argument undefined');
        }
        return value;
    };
    return ScryptType;
}());
exports.ScryptType = ScryptType;
var Int = /** @class */ (function (_super) {
    __extends(Int, _super);
    function Int(intVal) {
        return _super.call(this, intVal) || this;
    }
    Int.prototype.toLiteral = function () {
        return this._value.toString();
    };
    Int.prototype.checkValue = function (value) {
        _super.prototype.checkValue.call(this, value);
        if (!utils_1.isInteger(value)) {
            throw new Error('Only supports integers, should use integer number, bigint, hex string or decimal string');
        }
        if (typeof value == 'number' && !isNaN(value)) {
            if (!Number.isSafeInteger(value)) {
                throw new Error("<" + value + "> is not safe integer, should use bigint, hex string or decimal string");
            }
        }
        return value;
    };
    return Int;
}(ScryptType));
exports.Int = Int;
var Bool = /** @class */ (function (_super) {
    __extends(Bool, _super);
    function Bool(boolVal) {
        return _super.call(this, boolVal) || this;
    }
    Bool.prototype.toLiteral = function () {
        return this._value.toString();
    };
    return Bool;
}(ScryptType));
exports.Bool = Bool;
var Bytes = /** @class */ (function (_super) {
    __extends(Bytes, _super);
    function Bytes(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    Bytes.prototype.toLiteral = function () {
        return "b'" + utils_1.getValidatedHexString(this._value.toString()) + "'";
    };
    return Bytes;
}(ScryptType));
exports.Bytes = Bytes;
var PrivKey = /** @class */ (function (_super) {
    __extends(PrivKey, _super);
    function PrivKey(intVal) {
        return _super.call(this, intVal) || this;
    }
    PrivKey.prototype.toLiteral = function () {
        if (typeof this._value === 'string') {
            return "PrivKey(" + this._value + ")";
        }
        else {
            var v = this._value;
            return "PrivKey(0x" + utils_1.intValue2hex(v) + ")";
        }
    };
    return PrivKey;
}(ScryptType));
exports.PrivKey = PrivKey;
var PubKey = /** @class */ (function (_super) {
    __extends(PubKey, _super);
    function PubKey(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    PubKey.prototype.toLiteral = function () {
        return "PubKey(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return PubKey;
}(ScryptType));
exports.PubKey = PubKey;
var Sig = /** @class */ (function (_super) {
    __extends(Sig, _super);
    function Sig(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    Sig.prototype.toLiteral = function () {
        return "Sig(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return Sig;
}(ScryptType));
exports.Sig = Sig;
var Ripemd160 = /** @class */ (function (_super) {
    __extends(Ripemd160, _super);
    function Ripemd160(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    Ripemd160.prototype.toLiteral = function () {
        return "Ripemd160(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return Ripemd160;
}(ScryptType));
exports.Ripemd160 = Ripemd160;
var Sha1 = /** @class */ (function (_super) {
    __extends(Sha1, _super);
    function Sha1(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    Sha1.prototype.toLiteral = function () {
        return "Sha1(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return Sha1;
}(ScryptType));
exports.Sha1 = Sha1;
var Sha256 = /** @class */ (function (_super) {
    __extends(Sha256, _super);
    function Sha256(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    Sha256.prototype.toLiteral = function () {
        return "Sha256(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return Sha256;
}(ScryptType));
exports.Sha256 = Sha256;
var SigHash;
(function (SigHash) {
    SigHash[SigHash["ALL"] = 1] = "ALL";
    SigHash[SigHash["NONE"] = 2] = "NONE";
    SigHash[SigHash["SINGLE"] = 3] = "SINGLE";
    SigHash[SigHash["FORKID"] = 64] = "FORKID";
    SigHash[SigHash["ANYONECANPAY"] = 128] = "ANYONECANPAY";
})(SigHash = exports.SigHash || (exports.SigHash = {}));
var SigHashType = /** @class */ (function (_super) {
    __extends(SigHashType, _super);
    function SigHashType(intVal) {
        return _super.call(this, intVal) || this;
    }
    SigHashType.prototype.toLiteral = function () {
        var hexStr = this._value.toString(16);
        if (hexStr.length % 2) {
            hexStr = '0' + hexStr;
        }
        return "SigHashType(b'" + hexStr + "')";
    };
    SigHashType.prototype.toString = function () {
        var types = [];
        var value = this._value;
        if ((value & SigHash.ANYONECANPAY) === SigHash.ANYONECANPAY) {
            types.push('SigHash.ANYONECANPAY');
            value = value - SigHash.ANYONECANPAY;
        }
        if ((value & SigHash.SINGLE) === SigHash.SINGLE) {
            types.push('SigHash.SINGLE');
            value = value - SigHash.SINGLE;
        }
        if ((value & SigHash.NONE) === SigHash.NONE) {
            types.push('SigHash.NONE');
            value = value - SigHash.NONE;
        }
        if ((value & SigHash.ALL) === SigHash.ALL) {
            types.push('SigHash.ALL');
            value = value - SigHash.ALL;
        }
        if ((value & SigHash.FORKID) === SigHash.FORKID) {
            types.push('SigHash.FORKID');
            value = value - SigHash.FORKID;
        }
        if (value === 0) {
            return types.join(' | ');
        }
        throw new Error("unknown sighash type value: " + this._value);
    };
    return SigHashType;
}(ScryptType));
exports.SigHashType = SigHashType;
var SigHashPreimage = /** @class */ (function (_super) {
    __extends(SigHashPreimage, _super);
    function SigHashPreimage(bytesVal) {
        var _this = _super.call(this, bytesVal) || this;
        _this._buf = Buffer.from(bytesVal, 'hex');
        return _this;
    }
    SigHashPreimage.prototype.getReader = function (buf) {
        return new bsv.encoding.BufferReader(buf);
    };
    Object.defineProperty(SigHashPreimage.prototype, "nVersion", {
        // nVersion of the transaction
        get: function () {
            return this.getReader(this._buf.slice(0, 4)).readUInt32LE();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "hashPrevouts", {
        // hashPrevouts
        get: function () {
            return this._buf.slice(4, 4 + 32).toString('hex');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "hashSequence", {
        // hashSequence
        get: function () {
            return this._buf.slice(36, 36 + 32).toString('hex');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "outpoint", {
        // outpoint
        get: function () {
            var buf = this._buf.slice(68, 68 + 32 + 4);
            var hex = buf.toString('hex');
            var index = this.getReader(buf.slice(32, 32 + 4)).readUInt32LE();
            var hash = Buffer.from(buf.slice(0, 32)).reverse().toString('hex');
            return {
                hash: hash,
                index: index,
                hex: hex
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "scriptCode", {
        // scriptCode of the input
        get: function () {
            return this.getReader(this._buf.slice(104, this._buf.length - 52)).readVarLengthBuffer().toString('hex');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "amount", {
        // value of the output spent by this input
        get: function () {
            return this.getReader(this._buf.slice(this._buf.length - 44 - 8, this._buf.length - 44)).readUInt32LE();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "nSequence", {
        // nSequence of the input
        get: function () {
            return this.getReader(this._buf.slice(this._buf.length - 40 - 4, this._buf.length - 40)).readUInt32LE();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "hashOutputs", {
        // hashOutputs
        get: function () {
            return this._buf.slice(this._buf.length - 8 - 32, this._buf.length - 8).toString('hex');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "nLocktime", {
        // nLocktime of the transaction
        get: function () {
            return this.getReader(this._buf.slice(this._buf.length - 4 - 4, this._buf.length - 4)).readUInt32LE();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SigHashPreimage.prototype, "sighashType", {
        // sighash type of the signature
        get: function () {
            return this.getReader(this._buf.slice(this._buf.length - 4, this._buf.length)).readUInt32LE();
        },
        enumerable: false,
        configurable: true
    });
    SigHashPreimage.prototype.toString = function (format) {
        if (format === void 0) { format = 'hex'; }
        return this._buf.toString(format);
    };
    SigHashPreimage.prototype.toLiteral = function () {
        return "SigHashPreimage(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    SigHashPreimage.prototype.toJSONObject = function () {
        return {
            nVersion: this.nVersion,
            hashPrevouts: this.hashPrevouts,
            hashSequence: this.hashSequence,
            outpoint: this.outpoint,
            scriptCode: this.scriptCode,
            amount: this.amount,
            nSequence: this.nSequence,
            hashOutputs: this.hashOutputs,
            nLocktime: this.nLocktime,
            sighashType: new SigHashType(this.sighashType).toString()
        };
    };
    return SigHashPreimage;
}(ScryptType));
exports.SigHashPreimage = SigHashPreimage;
var OpCodeType = /** @class */ (function (_super) {
    __extends(OpCodeType, _super);
    function OpCodeType(bytesVal) {
        return _super.call(this, bytesVal) || this;
    }
    OpCodeType.prototype.toLiteral = function () {
        return "OpCodeType(b'" + utils_1.getValidatedHexString(this._value.toString()) + "')";
    };
    return OpCodeType;
}(ScryptType));
exports.OpCodeType = OpCodeType;
var Struct = /** @class */ (function (_super) {
    __extends(Struct, _super);
    function Struct(o) {
        var _this = _super.call(this, o) || this;
        _this.sorted = false;
        return _this;
    }
    Struct.prototype.bind = function () {
        var structAst = Object.getPrototypeOf(this).constructor.structAst;
        utils_1.checkStruct(structAst, this, this._typeResolver);
        var ordered = {};
        var unordered = this.value;
        Object.keys(this.value).sort(function (a, b) {
            return (structAst.params.findIndex(function (e) {
                return e.name === a;
            }) - structAst.params.findIndex(function (e) {
                return e.name === b;
            }));
        }).forEach(function (key) {
            ordered[key] = unordered[key];
        });
        this.sorted = true;
        this._type = structAst.name;
        this._value = ordered;
    };
    Struct.prototype.toASM = function () {
        if (!this.sorted) {
            throw 'unbinded Struct can\'t call toASM';
        }
        this._asm = utils_1.flatternStruct(this, '').map(function (v) {
            return v.value.toASM();
        }).join(' ');
        return this._asm;
    };
    /**
     * @deprecated use  flatternStruct, see toASM
     */
    Struct.prototype.toArray = function () {
        if (!this.sorted) {
            throw 'unbinded Struct can\'t call toArray';
        }
        var v = this.value;
        return Object.keys(v).map(function (key) {
            if (v[key] instanceof ScryptType) {
                return v[key];
            }
            else if (typeof v[key] === 'boolean') {
                return new Bool(v[key]);
            }
            else if (typeof v[key] === 'number') {
                return new Int(v[key]);
            }
            else if (typeof v[key] === 'bigint') {
                return new Int(v[key]);
            }
        });
    };
    Struct.prototype.memberByIndex = function (index) {
        if (!this.sorted) {
            throw 'unbinded Struct can\'t call memberByIndex';
        }
        var v = this.value;
        return Object.keys(v)[index];
    };
    /**
    * @deprecated use  getMemberFinalType
    */
    Struct.prototype.getMemberType = function (key) {
        var v = this.value;
        if (v[key] instanceof ScryptType) {
            return v[key].type;
        }
        else if (typeof v[key] === 'boolean') {
            return new Bool(v[key]).type;
        }
        else if (typeof v[key] === 'number') {
            return new Int(v[key]).type;
        }
        else if (typeof v[key] === 'bigint') {
            return new Int(v[key]).type;
        }
        else if (typeof v[key] === 'string') {
            return new Int(v[key]).type;
        }
        else {
            return typeof v[key];
        }
    };
    /**
     * Get the real member type of the structure
     */
    Struct.prototype.getMemberFinalType = function (key) {
        var member = this.memberByKey(key);
        return utils_1.typeOfArg(member);
    };
    /**
     * Get the member type declared by the structure by structAst
     */
    Struct.prototype.getMemberAstFinalType = function (key) {
        var structAst = Object.getPrototypeOf(this).constructor.structAst;
        var paramEntity = structAst.params.find(function (p) {
            return p.name === key;
        });
        if (!paramEntity) {
            throw new Error(key + " is member of struct " + structAst.name);
        }
        return this._typeResolver(paramEntity.type);
    };
    Struct.prototype.getMembers = function () {
        var v = this.value;
        return Object.keys(v);
    };
    Struct.prototype.memberByKey = function (key) {
        var v = this.value;
        if (v[key] instanceof ScryptType) {
            return v[key];
        }
        else if (typeof v[key] === 'boolean') {
            return new Bool(v[key]);
        }
        else if (typeof v[key] === 'number') {
            return new Int(v[key]);
        }
        else if (typeof v[key] === 'bigint') {
            return new Int(v[key]);
        }
        else if (typeof v[key] === 'string') {
            return new Int(v[key]);
        }
        return v[key];
    };
    Struct.arrayToLiteral = function (a) {
        var al = a.map(function (i) {
            if (Array.isArray(i)) {
                return Struct.arrayToLiteral(i);
            }
            return toScryptType(i).toLiteral();
        }).join(',');
        return "[" + al + "]";
    };
    Struct.prototype.toLiteral = function () {
        var v = this.value;
        var l = Object.keys(this.value).map(function (key) {
            if (Array.isArray(v[key])) {
                return Struct.arrayToLiteral(v[key]);
            }
            else {
                return toScryptType(v[key]).toLiteral();
            }
        }).join(',');
        return "{" + l + "}";
    };
    Struct.prototype.toJSON = function () {
        var v = this.value;
        return Array.from(Object.keys(v)).reduce(function (obj, key) {
            var _a, _b, _c, _d;
            if (v[key] instanceof ScryptType) {
                if (Struct.isStruct(v[key])) {
                    return Object.assign(obj, (_a = {}, _a[key] = v[key].toJSON(), _a));
                }
                else if (Array.isArray(v[key])) {
                    return Object.assign(obj, (_b = {}, _b[key] = JSON.stringify(v[key]), _b));
                }
                else {
                    return Object.assign(obj, (_c = {}, _c[key] = v[key].toLiteral(), _c));
                }
            }
            else {
                return Object.assign(obj, (_d = {}, _d[key] = v[key], _d));
            }
        }, {});
    };
    Struct.isStruct = function (arg) {
        return arg instanceof Struct;
    };
    return Struct;
}(ScryptType));
exports.Struct = Struct;
var VariableType;
(function (VariableType) {
    VariableType["BOOL"] = "bool";
    VariableType["INT"] = "int";
    VariableType["BYTES"] = "bytes";
    VariableType["PUBKEY"] = "PubKey";
    VariableType["PRIVKEY"] = "PrivKey";
    VariableType["SIG"] = "Sig";
    VariableType["RIPEMD160"] = "Ripemd160";
    VariableType["SHA1"] = "Sha1";
    VariableType["SHA256"] = "Sha256";
    VariableType["SIGHASHTYPE"] = "SigHashType";
    VariableType["SIGHASHPREIMAGE"] = "SigHashPreimage";
    VariableType["OPCODETYPE"] = "OpCodeType";
    VariableType["STRUCT"] = "struct";
})(VariableType = exports.VariableType || (exports.VariableType = {}));
exports.BasicType = Object.keys(VariableType).map(function (key) { return VariableType[key]; });
exports.BasicScryptType = (_a = {},
    _a[VariableType.BOOL] = Bool,
    _a[VariableType.INT] = Int,
    _a[VariableType.BYTES] = Bytes,
    _a[VariableType.PUBKEY] = PubKey,
    _a[VariableType.PRIVKEY] = PrivKey,
    _a[VariableType.SIG] = Sig,
    _a[VariableType.RIPEMD160] = Ripemd160,
    _a[VariableType.SHA1] = Sha1,
    _a[VariableType.SHA256] = Sha256,
    _a[VariableType.SIGHASHTYPE] = SigHashType,
    _a[VariableType.OPCODETYPE] = OpCodeType,
    _a[VariableType.SIGHASHPREIMAGE] = SigHashPreimage,
    _a);
//# sourceMappingURL=scryptTypes.js.map