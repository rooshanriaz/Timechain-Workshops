"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.desc2CompileResult = exports.getDefaultScryptc = exports.getPlatformScryptc = exports.getStaticConstIntDeclaration = exports.getAliasDeclaration = exports.getStructDeclaration = exports.getABIDeclaration = exports.compilerVersion = exports.compile = exports.ABIEntityType = exports.DebugModeTag = exports.BuildType = exports.CompileErrorType = void 0;
var path_1 = require("path");
var child_process_1 = require("child_process");
var fs_1 = require("fs");
var os = require("os");
var md5 = require("md5");
var utils_1 = require("./utils");
var compareVersions = require("compare-versions");
var JSONbig = require("json-bigint");
var SYNTAX_ERR_REG = /(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):\n([^\n]+\n){3}(unexpected (?<unexpected>[^\n]+)\nexpecting (?<expecting>[^\n]+)|(?<message>[^\n]+))/g;
var SEMANTIC_ERR_REG = /Error:(\s|\n)*(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+):*\n(?<message>[^\n]+)\n/g;
var INTERNAL_ERR_REG = /Internal error:(?<message>.+)/;
var WARNING_REG = /Warning:(\s|\n)*(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+):*\n(?<message>[^\n]+)\n/g;
var JSONbigAlways = JSONbig({ alwaysParseAsBig: true, constructorAction: 'preserve' });
//SOURCE_REG parser src eg: [0:6:3:8:4#Bar.constructor:0]
var SOURCE_REG = /^(?<fileIndex>-?\d+):(?<line>\d+):(?<col>\d+):(?<endLine>\d+):(?<endCol>\d+)(#(?<tagStr>.+))?/;
var RELATED_INFORMATION_REG = /(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+)/gi;
// see VERSIONLOG.md
var CURRENT_CONTRACT_DESCRIPTION_VERSION = 4;
var CompileErrorType;
(function (CompileErrorType) {
    CompileErrorType["SyntaxError"] = "SyntaxError";
    CompileErrorType["SemanticError"] = "SemanticError";
    CompileErrorType["InternalError"] = "InternalError";
    CompileErrorType["Warning"] = "Warning";
})(CompileErrorType = exports.CompileErrorType || (exports.CompileErrorType = {}));
var BuildType;
(function (BuildType) {
    BuildType["Debug"] = "debug";
    BuildType["Release"] = "release";
})(BuildType = exports.BuildType || (exports.BuildType = {}));
var DebugModeTag;
(function (DebugModeTag) {
    DebugModeTag["FuncStart"] = "F0";
    DebugModeTag["FuncEnd"] = "F1";
    DebugModeTag["LoopStart"] = "L0";
})(DebugModeTag = exports.DebugModeTag || (exports.DebugModeTag = {}));
var ABIEntityType;
(function (ABIEntityType) {
    ABIEntityType["FUNCTION"] = "function";
    ABIEntityType["CONSTRUCTOR"] = "constructor";
})(ABIEntityType = exports.ABIEntityType || (exports.ABIEntityType = {}));
function compile(source, settings) {
    if (settings === void 0) { settings = {
        asm: true,
        debug: true,
    }; }
    var st = Date.now();
    var sourcePath = source.path;
    var srcDir = path_1.dirname(sourcePath);
    var curWorkingDir = settings.cwd || srcDir;
    var sourceFileName = path_1.basename(sourcePath);
    var outputDir = settings.outputDir || srcDir;
    var timeout = settings.timeout || 1200000;
    var outputFiles = {};
    try {
        var sourceContent = source.content !== undefined ? source.content : fs_1.readFileSync(sourcePath, 'utf8');
        var cmdPrefix = settings.cmdPrefix || getDefaultScryptc();
        var cmd = cmdPrefix + " compile " + (settings.asm || settings.desc ? '--asm' : '') + " " + (settings.ast || settings.desc ? '--ast' : '') + " " + (settings.debug == false ? '' : '--debug') + " -r -o \"" + outputDir + "\" " + (settings.cmdArgs ? settings.cmdArgs : '');
        var output = child_process_1.execSync(cmd, { input: sourceContent, cwd: curWorkingDir, timeout: timeout }).toString();
        // Because the output of the compiler on the win32 platform uses crlf as a newline， here we change \r\n to \n. make SYNTAX_ERR_REG、SEMANTIC_ERR_REG、IMPORT_ERR_REG work.
        output = output.split(/\r?\n/g).join('\n');
        var result = { errors: [], warnings: [] };
        if (output.startsWith('Error:') || output.startsWith('Warning:')) {
            result = getErrorsAndWarnings(output, srcDir, sourceFileName);
            if (result.errors.length > 0) {
                return result;
            }
        }
        if (settings.ast || settings.desc) {
            var outputFilePath = getOutputFilePath(outputDir, 'ast');
            outputFiles['ast'] = outputFilePath;
            var allAst = addSourceLocation(JSONbigAlways.parse(fs_1.readFileSync(outputFilePath, 'utf8')), srcDir, sourceFileName);
            var sourceUri = utils_1.path2uri(sourcePath);
            result.file = sourceUri;
            result.ast = allAst[sourceUri];
            delete allAst[sourceUri];
            result.dependencyAsts = allAst;
            result.alias = getAliasDeclaration(result.ast, allAst);
            result.staticConst = getStaticConstIntDeclaration(result.ast, allAst);
            var _a = getABIDeclaration(result.ast, result.alias, result.staticConst), name_1 = _a.contract, abi = _a.abi;
            result.abi = abi;
            result.contract = name_1;
            result.structs = getStructDeclaration(result.ast, allAst);
        }
        var asmObj = null;
        if (settings.asm || settings.desc) {
            var outputFilePath = getOutputFilePath(outputDir, 'asm');
            outputFiles['asm'] = outputFilePath;
            asmObj = JSON.parse(fs_1.readFileSync(outputFilePath, 'utf8'));
            var sources_1 = asmObj.sources;
            result.asm = asmObj.output.map(function (item) {
                if (!settings.debug) {
                    return {
                        opcode: item.opcode
                    };
                }
                var match = SOURCE_REG.exec(item.src);
                if (match && match.groups) {
                    var fileIndex = parseInt(match.groups.fileIndex);
                    var debugTag = void 0;
                    var tagStr = match.groups.tagStr;
                    if (/\w+\.\w+:0/.test(tagStr)) {
                        debugTag = DebugModeTag.FuncStart;
                    }
                    if (/\w+\.\w+:1/.test(tagStr)) {
                        debugTag = DebugModeTag.FuncEnd;
                    }
                    if (/loop:0/.test(tagStr)) {
                        debugTag = DebugModeTag.LoopStart;
                    }
                    var pos = sources_1[fileIndex] ? {
                        file: sources_1[fileIndex] ? getFullFilePath(sources_1[fileIndex], srcDir, sourceFileName) : undefined,
                        line: sources_1[fileIndex] ? parseInt(match.groups.line) : undefined,
                        endLine: sources_1[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                        column: sources_1[fileIndex] ? parseInt(match.groups.col) : undefined,
                        endColumn: sources_1[fileIndex] ? parseInt(match.groups.endCol) : undefined,
                    } : undefined;
                    return {
                        opcode: item.opcode,
                        stack: item.stack,
                        topVars: item.topVars || [],
                        pos: pos,
                        debugTag: debugTag
                    };
                }
                throw new Error('Compile Failed: Asm output parsing Error!');
            });
            if (settings.debug) {
                result.autoTypedVars = asmObj.autoTypedVars.map(function (item) {
                    var match = SOURCE_REG.exec(item.src);
                    if (match && match.groups) {
                        var fileIndex = parseInt(match.groups.fileIndex);
                        var pos = sources_1[fileIndex] ? {
                            file: sources_1[fileIndex] ? getFullFilePath(sources_1[fileIndex], srcDir, sourceFileName) : undefined,
                            line: sources_1[fileIndex] ? parseInt(match.groups.line) : undefined,
                            endLine: sources_1[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                            column: sources_1[fileIndex] ? parseInt(match.groups.col) : undefined,
                            endColumn: sources_1[fileIndex] ? parseInt(match.groups.endCol) : undefined,
                        } : undefined;
                        return {
                            name: item.name,
                            type: item.type,
                            pos: pos
                        };
                    }
                });
            }
        }
        if (settings.desc) {
            settings.outputToFiles = true;
            var outputFilePath = getOutputFilePath(outputDir, 'desc');
            outputFiles['desc'] = outputFilePath;
            var description = {
                version: CURRENT_CONTRACT_DESCRIPTION_VERSION,
                compilerVersion: compilerVersion(settings.cmdPrefix ? settings.cmdPrefix : getDefaultScryptc()),
                contract: result.contract,
                md5: md5(sourceContent),
                structs: result.structs || [],
                alias: result.alias || [],
                abi: result.abi || [],
                buildType: settings.buildType || BuildType.Debug,
                file: '',
                asm: result.asm.map(function (item) { return item['opcode'].trim(); }).join(' '),
                sources: [],
                sourceMap: []
            };
            if (settings.debug && asmObj) {
                Object.assign(description, {
                    file: result.file,
                    sources: asmObj.sources.map(function (source) { return getFullFilePath(source, srcDir, sourceFileName); }),
                    sourceMap: asmObj.output.map(function (item) { return item.src; }),
                });
            }
            fs_1.writeFileSync(outputFilePath, JSON.stringify(description, null, 4));
            result.compilerVersion = description.compilerVersion;
            result.md5 = description.md5;
        }
        return result;
    }
    finally {
        if (settings.outputToFiles) {
            Object.keys(outputFiles).forEach(function (outputType) {
                var file = outputFiles[outputType];
                if (fs_1.existsSync(file)) {
                    if (settings[outputType]) {
                        // rename all output files
                        fs_1.renameSync(file, file.replace('stdin', path_1.basename(sourcePath, '.scrypt')));
                    }
                    else {
                        fs_1.unlinkSync(file);
                    }
                }
            });
        }
        else {
            // cleanup all output files
            Object.values(outputFiles).forEach(function (file) {
                if (fs_1.existsSync(file)) {
                    fs_1.unlinkSync(file);
                }
            });
        }
        // console.log('compile time spent: ', Date.now() - st)
    }
}
exports.compile = compile;
function compilerVersion(cwd) {
    try {
        var text = child_process_1.execSync(cwd + " version").toString();
        return /Version:\s*([^\s]+)\s*/.exec(text)[1];
    }
    catch (e) {
        throw new Error("compilerVersion fail when run: " + cwd + " version");
    }
}
exports.compilerVersion = compilerVersion;
function addSourceLocation(astRoot, basePath, curFileName) {
    for (var fileName in astRoot) {
        if (fileName === 'std') {
            astRoot['std'] = _addSourceLocationProperty(astRoot['std'], 'std');
        }
        else {
            var realFileName = fileName === 'stdin' ? curFileName : fileName;
            var uri = utils_1.path2uri(path_1.join(basePath, realFileName));
            astRoot[uri] = _addSourceLocationProperty(astRoot[fileName], uri);
            delete astRoot[fileName];
        }
    }
    return astRoot;
}
function _addSourceLocationProperty(astObj, uri) {
    if (!(typeof astObj === 'object')) {
        return astObj;
    }
    for (var field in astObj) {
        var value = astObj[field];
        if (field === 'src') {
            var matches = /:(\d+):(\d+):(\d+):(\d+)/.exec(value);
            if (!matches) {
                astObj.loc = null;
            }
            else {
                astObj.loc = {
                    source: uri,
                    start: { line: parseInt(matches[1]), column: parseInt(matches[2]) },
                    end: { line: parseInt(matches[3]), column: parseInt(matches[4]) }
                };
            }
            delete astObj['src'];
        }
        else if (typeof value === 'object') {
            _addSourceLocationProperty(value, uri);
        }
    }
    return astObj;
}
function getOutputFilePath(baseDir, target) {
    return path_1.join(baseDir, "stdin_" + target + ".json");
}
function getFullFilePath(relativePath, baseDir, curFileName) {
    if (relativePath.endsWith('stdin')) {
        return path_1.join(baseDir, curFileName); // replace 'stdin' with real current compiling file name.
    }
    if (relativePath === 'std') {
        return 'std'; // 
    }
    return path_1.join(baseDir, relativePath);
}
function getConstructorDeclaration(mainContract) {
    // explict constructor
    if (mainContract['constructor']) {
        return {
            type: ABIEntityType.CONSTRUCTOR,
            params: mainContract['constructor']['params'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
        };
    }
    else {
        // implicit constructor
        if (mainContract['properties']) {
            return {
                type: ABIEntityType.CONSTRUCTOR,
                params: mainContract['properties'].map(function (p) { return { name: p['name'].replace('this.', ''), type: p['type'] }; }),
            };
        }
    }
}
function getPublicFunctionDeclaration(mainContract) {
    var pubIndex = 0;
    var interfaces = mainContract['functions']
        .filter(function (f) { return f['visibility'] === 'Public'; })
        .map(function (f) {
        var entity = {
            type: ABIEntityType.FUNCTION,
            name: f['name'],
            index: f['nodeType'] === 'Constructor' ? undefined : pubIndex++,
            params: f['params'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
        };
        return entity;
    });
    return interfaces;
}
function getABIDeclaration(astRoot, alias, staticConstInt) {
    var mainContract = astRoot['contracts'][astRoot['contracts'].length - 1];
    if (!mainContract) {
        return {
            contract: '',
            abi: []
        };
    }
    var interfaces = getPublicFunctionDeclaration(mainContract);
    var constructorABI = getConstructorDeclaration(mainContract);
    interfaces.push(constructorABI);
    interfaces.forEach(function (abi) {
        abi.params = abi.params.map(function (param) {
            return Object.assign(param, {
                type: resolveAbiParamType(mainContract['name'], param.type, alias, staticConstInt)
            });
        });
    });
    return {
        contract: mainContract['name'],
        abi: interfaces
    };
}
exports.getABIDeclaration = getABIDeclaration;
function resolveAbiParamType(contract, type, alias, staticConstInt) {
    var resolvedAliasType = utils_1.resolveType(alias, type);
    var resolvedConstIntType = utils_1.resolveStaticConst(contract, resolvedAliasType, staticConstInt);
    if (utils_1.isStructType(resolvedConstIntType)) {
        return utils_1.getStructNameByType(resolvedConstIntType);
    }
    else if (utils_1.isArrayType(resolvedConstIntType)) {
        var _a = __read(utils_1.arrayTypeAndSize(resolvedConstIntType), 2), elemTypeName = _a[0], arraySizes = _a[1];
        var elemType = utils_1.isStructType(elemTypeName) ? utils_1.getStructNameByType(elemTypeName) : elemTypeName;
        return utils_1.toLiteralArrayType(elemType, arraySizes);
    }
    return resolvedConstIntType;
}
function getStructDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    var staticConst = getStaticConstIntDeclaration(astRoot, dependencyAsts);
    return allAst.map(function (ast) {
        return (ast.structs || []).map(function (s) { return ({
            name: s['name'],
            params: s['fields'].map(function (p) { return { name: p['name'], type: utils_1.resolveStaticConst('', p['type'], staticConst) }; }),
        }); });
    }).flat(1);
}
exports.getStructDeclaration = getStructDeclaration;
function getAliasDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    var staticConst = getStaticConstIntDeclaration(astRoot, dependencyAsts);
    return allAst.map(function (ast) {
        return (ast.alias || []).map(function (s) { return ({
            name: s['alias'],
            type: utils_1.resolveStaticConst('', s['type'], staticConst),
        }); });
    }).flat(1);
}
exports.getAliasDeclaration = getAliasDeclaration;
function getStaticConstIntDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    return allAst.map(function (ast, index) {
        return (ast.contracts || []).map(function (contract) {
            return (contract.statics || []).filter(function (s) { return (s.const === true && s.expr.nodeType === 'IntLiteral'); }).map(function (s) {
                return {
                    name: contract.name + "." + s.name,
                    value: s.expr.value
                };
            });
        });
    }).flat(Infinity).reduce(function (acc, item) { return (acc[item.name] = item.value, acc); }, {});
}
exports.getStaticConstIntDeclaration = getStaticConstIntDeclaration;
function getPlatformScryptc() {
    switch (os.platform()) {
        case 'win32':
            return 'compiler/scryptc/win32/scryptc.exe';
        case 'linux':
            return 'compiler/scryptc/linux/scryptc';
        case 'darwin':
            return 'compiler/scryptc/mac/scryptc';
        default:
            throw "sCrypt doesn't support " + os.platform();
    }
}
exports.getPlatformScryptc = getPlatformScryptc;
function vscodeExtensionPath() {
    var homedir = os.homedir();
    var extensionPath = path_1.join(homedir, '.vscode/extensions');
    if (!fs_1.existsSync(extensionPath)) {
        throw 'No Visual Studio Code extensions found. Please ensure Visual Studio Code is installed.';
    }
    return extensionPath;
}
function findVscodeScrypt(extensionPath) {
    var sCryptPrefix = 'bsv-scrypt.scrypt-';
    var versions = fs_1.readdirSync(extensionPath).reduce(function (filtered, item) {
        if (item.indexOf(sCryptPrefix) > -1) {
            var version = item.substring(sCryptPrefix.length);
            if (compareVersions.validate(version)) {
                filtered.push(version);
            }
        }
        return filtered;
    }, []);
    // compareVersions is ascending, so reverse.
    versions = versions.sort(compareVersions).reverse();
    return sCryptPrefix + versions[0];
}
function getDefaultScryptc() {
    var extensionPath = vscodeExtensionPath();
    var sCrypt = findVscodeScrypt(extensionPath);
    if (!sCrypt) {
        throw "No sCrypt extension found. Please install it at extension marketplace:\n\t\thttps://marketplace.visualstudio.com/items?itemName=bsv-scrypt.sCrypt";
    }
    var scryptc = path_1.join(extensionPath, sCrypt, getPlatformScryptc());
    if (!fs_1.existsSync(scryptc)) {
        throw 'No sCrypt compiler found. Please update your sCrypt extension to the latest version';
    }
    return scryptc;
}
exports.getDefaultScryptc = getDefaultScryptc;
function desc2CompileResult(description) {
    var sources = description.sources;
    var asm = description.asm.split(' ');
    var errorMessage = 'Contract description version deprecated,  Please update your sCrypt extension to the latest version and recompile';
    if (description.version === undefined) {
        throw new Error(errorMessage);
    }
    if (description.version < CURRENT_CONTRACT_DESCRIPTION_VERSION) {
        console.warn(errorMessage);
    }
    var result = {
        compilerVersion: description.compilerVersion,
        contract: description.contract,
        md5: description.md5,
        abi: description.abi,
        structs: description.structs,
        alias: description.alias,
        file: description.file,
        buildType: description.buildType || BuildType.Debug,
        errors: [],
        warnings: [],
        staticConst: {},
        asm: asm.map(function (opcode, index) {
            var item = description.sourceMap && description.sourceMap[index];
            if (item) {
                var match = SOURCE_REG.exec(item);
                if (match && match.groups) {
                    var fileIndex = parseInt(match.groups.fileIndex);
                    var pos = sources[fileIndex] ? {
                        file: sources[fileIndex],
                        line: sources[fileIndex] ? parseInt(match.groups.line) : undefined,
                        endLine: sources[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                        column: sources[fileIndex] ? parseInt(match.groups.col) : undefined,
                        endColumn: sources[fileIndex] ? parseInt(match.groups.endCol) : undefined,
                    } : undefined;
                    return {
                        pos: pos,
                        opcode: opcode,
                        stack: [],
                        topVars: []
                    };
                }
            }
            return {
                opcode: opcode,
                stack: [],
                topVars: []
            };
        })
    };
    return result;
}
exports.desc2CompileResult = desc2CompileResult;
function getRelatedInformation(message, srcDir, sourceFileName) {
    var _a, _b, _c, _d;
    var relatedInformation = [];
    var result;
    while ((result = RELATED_INFORMATION_REG.exec(message))) {
        var relatedFilePath = result.groups.filePath;
        var fullFilePath = getFullFilePath(relatedFilePath, srcDir, sourceFileName);
        var line = parseInt(((_a = result.groups) === null || _a === void 0 ? void 0 : _a.line) || '-1');
        var column = parseInt(((_b = result.groups) === null || _b === void 0 ? void 0 : _b.column) || '-1');
        relatedInformation.push({
            filePath: fullFilePath,
            position: [{
                    line: line,
                    column: column,
                }, {
                    line: parseInt(((_c = result.groups) === null || _c === void 0 ? void 0 : _c.line1) || '-1'),
                    column: parseInt(((_d = result.groups) === null || _d === void 0 ? void 0 : _d.column1) || '-1'),
                }],
            message: ''
        });
        message = message.replace(/([^\s]+):(\d+):(\d+):(\d+):(\d+)/, '');
    }
    return {
        relatedInformation: relatedInformation,
        message: message
    };
}
function getErrorsAndWarnings(output, srcDir, sourceFileName) {
    var _a;
    var warnings = __spread(output.matchAll(WARNING_REG)).map(function (match) {
        var _a, _b, _c, _d, _e, _f;
        var filePath = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.filePath) || '';
        var origin_message = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.message) || '';
        var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
        return {
            type: CompileErrorType.Warning,
            filePath: getFullFilePath(filePath, srcDir, sourceFileName),
            position: [{
                    line: parseInt(((_c = match.groups) === null || _c === void 0 ? void 0 : _c.line) || '-1'),
                    column: parseInt(((_d = match.groups) === null || _d === void 0 ? void 0 : _d.column) || '-1'),
                }, {
                    line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line1) || '-1'),
                    column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column1) || '-1'),
                }],
            message: message,
            relatedInformation: relatedInformation
        };
    });
    if (output.match(INTERNAL_ERR_REG)) {
        return {
            warnings: warnings,
            errors: [{
                    type: CompileErrorType.InternalError,
                    filePath: getFullFilePath('stdin', srcDir, sourceFileName),
                    message: "Compiler internal error: " + (((_a = output.match(INTERNAL_ERR_REG).groups) === null || _a === void 0 ? void 0 : _a.message) || ''),
                    position: [{
                            line: 1,
                            column: 1
                        }, {
                            line: 1,
                            column: 1
                        }],
                    relatedInformation: []
                }]
        };
    }
    else if (output.includes('Syntax error:')) {
        var syntaxErrors = __spread(output.matchAll(SYNTAX_ERR_REG)).map(function (match) {
            var _a, _b, _c, _d, _e, _f;
            var filePath = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.filePath) || '';
            var unexpected = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.unexpected) || '';
            var expecting = ((_c = match.groups) === null || _c === void 0 ? void 0 : _c.expecting) || '';
            var origin_message = ((_d = match.groups) === null || _d === void 0 ? void 0 : _d.message) || "unexpected " + unexpected + "\nexpecting " + expecting;
            var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
            return {
                type: CompileErrorType.SyntaxError,
                filePath: getFullFilePath(filePath, srcDir, sourceFileName),
                position: [{
                        line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line) || '-1'),
                        column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column) || '-1'),
                    }],
                message: message,
                unexpected: unexpected,
                expecting: expecting,
                relatedInformation: relatedInformation
            };
        });
        return {
            warnings: warnings,
            errors: syntaxErrors
        };
    }
    else {
        var semanticErrors = __spread(output.matchAll(SEMANTIC_ERR_REG)).map(function (match) {
            var _a, _b, _c, _d, _e, _f;
            var origin_message = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.message) || '';
            var filePath = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.filePath) || '';
            var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
            return {
                type: CompileErrorType.SemanticError,
                filePath: getFullFilePath(filePath, srcDir, sourceFileName),
                position: [{
                        line: parseInt(((_c = match.groups) === null || _c === void 0 ? void 0 : _c.line) || '-1'),
                        column: parseInt(((_d = match.groups) === null || _d === void 0 ? void 0 : _d.column) || '-1'),
                    }, {
                        line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line1) || '-1'),
                        column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column1) || '-1'),
                    }],
                message: message,
                relatedInformation: relatedInformation
            };
        });
        return {
            warnings: warnings,
            errors: semanticErrors
        };
    }
}
//# sourceMappingURL=compilerWrapper.js.map