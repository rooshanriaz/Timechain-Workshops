"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeState = exports.serializeState = exports.STATE_LEN_4BYTES = exports.STATE_LEN_2BYTES = void 0;
var utils_1 = require("./utils");
var Script = utils_1.bsv.Script;
var Opcode = utils_1.bsv.Opcode;
var BN = utils_1.bsv.crypto.BN;
// number of bytes to denote state length after serialization, exclusing varint prefix
exports.STATE_LEN_2BYTES = 2;
exports.STATE_LEN_4BYTES = 4;
function serializeBool(flag) {
    return flag ? 'OP_TRUE' : 'OP_FALSE';
}
function serializeInt(n) {
    var num = new BN(n);
    if (num.eqn(0)) {
        return '00';
    }
    return num.toSM({ endian: 'little' }).toString('hex');
}
function serializeString(str) {
    if (str === '') {
        return '00';
    }
    var buf = Buffer.from(str, 'utf8');
    return buf.toString('hex');
}
// TODO: validate
function serializeBytes(hexStr) {
    return hexStr;
}
function serializeWithSchema(state, key, schema) {
    if (schema === void 0) { schema = undefined; }
    var type = schema[key];
    if (type === 'boolean') {
        return serializeBool(state[key]);
    }
    else if (type === 'number') {
        return serializeInt(state[key]);
    }
    else if (type === 'bigint') {
        return serializeInt(state[key]);
    }
    else if (type === 'string') {
        return serializeString(state[key]);
    }
    else {
        return serializeBytes(state[key]);
    }
}
function serialize(x) {
    if (typeof x === 'boolean') {
        return serializeBool(x);
    }
    if (typeof x === 'number') {
        return serializeInt(x);
    }
    if (typeof x === 'bigint') {
        return serializeInt(x);
    }
    else {
        return serializeBytes(x);
    }
}
// serialize contract state into Script ASM
function serializeState(state, stateBytes, schema) {
    var e_1, _a;
    if (stateBytes === void 0) { stateBytes = exports.STATE_LEN_2BYTES; }
    if (schema === void 0) { schema = undefined; }
    var asms = [];
    var keys = Object.keys(state);
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (schema) {
                var str = serializeWithSchema(state, key, schema);
                asms.push(str);
            }
            else {
                var str = serialize(state[key]);
                asms.push(str);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var script = Script.fromASM(asms.join(' '));
    var scriptHex = script.toHex();
    var stateLen = scriptHex.length / 2;
    // use fixed size to denote state len
    var len = utils_1.num2bin(stateLen, stateBytes);
    return script.toASM() + ' ' + len;
}
exports.serializeState = serializeState;
var OpState = /** @class */ (function () {
    function OpState(op) {
        this.op = op;
    }
    OpState.prototype.toNumber = function () {
        if (this.op.opcodenum === Opcode.OP_1) {
            return Number(1);
        }
        else if (this.op.opcodenum === Opcode.OP_0) {
            return Number(0);
        }
        else if (this.op.opcodenum === Opcode.OP_1NEGATE) {
            return Number(-1);
        }
        else if (this.op.opcodenum >= Opcode.OP_2 && this.op.opcodenum <= Opcode.OP_16) {
            return Number(this.op.opcodenum - Opcode.OP_2 + 2);
        }
        else {
            if (!this.op.buf)
                throw new Error('state does not have a number representation');
            return Number(utils_1.bin2num(this.op.buf));
        }
    };
    OpState.prototype.toBigInt = function () {
        if (this.op.opcodenum === Opcode.OP_1) {
            return BigInt(1);
        }
        else if (this.op.opcodenum === Opcode.OP_0) {
            return BigInt(0);
        }
        else if (this.op.opcodenum === Opcode.OP_1NEGATE) {
            return BigInt(-1);
        }
        else if (this.op.opcodenum >= Opcode.OP_2 && this.op.opcodenum <= Opcode.OP_16) {
            return BigInt(this.op.opcodenum - Opcode.OP_2 + 2);
        }
        else {
            if (!this.op.buf)
                throw new Error('state does not have a number representation');
            return utils_1.bin2num(this.op.buf);
        }
    };
    OpState.prototype.toBoolean = function () {
        return this.toNumber() !== Number(0);
    };
    OpState.prototype.toHex = function () {
        if (!this.op.buf)
            throw new Error('state does not have a hexadecimal representation');
        return this.op.buf.toString('hex');
    };
    OpState.prototype.toString = function (arg) {
        if (arg === void 0) { arg = 'utf8'; }
        if (!this.op.buf) {
            throw new Error('state does not have a string representation');
        }
        if (this.op.buf[0] === 0) {
            return '';
        }
        return this.op.buf.toString(arg);
    };
    return OpState;
}());
// deserialize Script or Script Hex or Script ASM Code to contract state array and object
function deserializeState(s, schema) {
    if (schema === void 0) { schema = undefined; }
    var script;
    try {
        script = new Script(s);
    }
    catch (e) {
        script = Script.fromASM(s);
    }
    var chunks = script.chunks;
    var states = [];
    var pos = chunks.length;
    //the last opcode is length of stats, skip
    for (var i = pos - 2; i >= 0; i--) {
        var opcodenum = chunks[i].opcodenum;
        if (opcodenum === Opcode.OP_RETURN) {
            break;
        }
        else {
            states.unshift(new OpState(chunks[i]));
        }
    }
    //deserialize to an array
    if (!schema) {
        return states;
    }
    //deserialize to an object
    var ret;
    if (Array.isArray(schema)) {
        ret = [];
    }
    else {
        ret = {};
    }
    var keys = Object.keys(schema);
    for (var i = 0; i < states.length; i++) {
        var key = keys[i];
        if (!key) {
            break;
        }
        var val = schema[key];
        if (val === 'boolean' || typeof val === 'boolean') {
            ret[key] = states[i].toBoolean();
        }
        else if (val === 'number' || typeof val === 'number') {
            ret[key] = states[i].toNumber();
        }
        else if (val === 'bigint' || typeof val === 'bigint') {
            if (typeof BigInt === 'function') {
                ret[key] = states[i].toBigInt();
            }
            else {
                ret[key] = states[i].toNumber();
            }
        }
        else if (val === 'string') {
            ret[key] = states[i].toString();
        }
        else {
            ret[key] = states[i].toHex();
        }
    }
    return ret;
}
exports.deserializeState = deserializeState;
//# sourceMappingURL=serializer.js.map