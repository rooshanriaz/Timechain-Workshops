"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SensiblequeryProvider = void 0;
const sensible_api_1 = require("@sensible-contract/sensible-api");
const base_provider_1 = require("./base-provider");
class SensiblequeryProvider extends base_provider_1.BaseProvider {
    constructor(network = "mainnet", apiPrefix) {
        super(network, "sensiblequery");
        if (!apiPrefix) {
            if (network == "mainnet") {
                apiPrefix = "https://api.sensiblequery.com";
            }
            else {
                apiPrefix = "https://api.sensiblequery.com/test";
            }
        }
        this.sensibleApi = new sensible_api_1.SensibleApi(apiPrefix);
    }
    getUtxos(address, queryParams) {
        return this.sensibleApi.getUtxos(address, queryParams);
    }
    getBalance(address) {
        return this.sensibleApi.getBalance(address);
    }
    getRawTx(txid) {
        return this.sensibleApi.getRawTx(txid);
    }
    broadcast(rawtx) {
        return this.sensibleApi.broadcast(rawtx);
    }
    getTokenUtxos(codehash, genesis, address, queryParams) {
        return this.sensibleApi.getTokenUtxos(codehash, genesis, address, queryParams);
    }
    getTokenBalance(codehash, genesis, address) {
        return this.sensibleApi.getTokenBalance(codehash, genesis, address);
    }
    getTokenList(address, queryParams) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getTokenList(address, queryParams);
            return _res.list.map((v) => ({
                codehash: v.codehash,
                genesis: v.genesis,
                sensibleId: v.sensibleId,
                name: v.name,
                symbol: v.symbol,
                decimal: v.decimal,
                balance: v.balance,
                pendingBalance: v.pendingBalance,
            }));
        });
    }
    getNftUtxos(codehash, genesis, address, queryParams) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getNftUtxoDatas(codehash, genesis, address, queryParams);
            let utxos = _res.utxo.map((v) => ({
                txId: v.txid,
                outputIndex: v.vout,
                tokenIndex: v.tokenIndex,
                tokenAddress: v.address,
                metaTxId: v.metaTxId,
                metaOutputIndex: v.metaOutputIndex,
            }));
            return utxos;
        });
    }
    getNftUtxo(codehash, genesis, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getNftUtxoDetail(codehash, genesis, tokenIndex);
            return {
                txId: _res.txid,
                outputIndex: _res.vout,
                tokenIndex: _res.tokenIndex,
                tokenAddress: _res.address,
                metaTxId: _res.metaTxId,
                metaOutputIndex: _res.metaOutputIndex,
            };
        });
    }
    getNftCollectionList(address, queryParams) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getNftSummary(address, queryParams);
            return _res.map((v) => ({
                codehash: v.codehash,
                genesis: v.genesis,
                sensibleId: v.sensibleId,
                count: (v.count + v.pendingCount).toString(),
            }));
        });
    }
    getIsUtxoSpent(txId, outputIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getTxOutSpent(txId, outputIndex);
            if (_res) {
                return true;
            }
            else {
                return false;
            }
        });
    }
    //implement NftAuctionProvider
    getNftAuctionUtxo(codehash, nftid) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getNftAuctionUtxoDetails(codehash, nftid, false);
            let detail = _res[0];
            if (detail) {
                return {
                    txId: detail.txid,
                    outputIndex: detail.vout,
                };
            }
        });
    }
    //implement NftSellProvider
    getNftSellUtxo(codehash, genesis, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let _res = yield this.sensibleApi.getNftSellUtxoDetail(codehash, genesis, tokenIndex, { ready: false });
            let detail = _res[0];
            if (detail) {
                return {
                    txId: detail.txid,
                    outputIndex: detail.vout,
                    sellerAddress: detail.address,
                    satoshisPrice: detail.price
                };
            }
        });
    }
}
exports.SensiblequeryProvider = SensiblequeryProvider;
//# sourceMappingURL=sensiblequery-provider.js.map