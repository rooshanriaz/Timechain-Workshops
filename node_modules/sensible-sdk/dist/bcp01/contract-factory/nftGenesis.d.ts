import * as bsv from "../../bsv";
import { ContractAdapter } from "../../common/ContractAdapter";
import { Bytes, FunctionCall, Int, Ripemd160, Sig, SigHashPreimage } from "../../scryptlib";
import * as nftProto from "../contract-proto/nft.proto";
export declare class NftGenesis extends ContractAdapter {
    constuctParams: {
        issuerPubKey: bsv.PublicKey;
    };
    private _formatedDataPart;
    constructor(constuctParams: {
        issuerPubKey: bsv.PublicKey;
    });
    clone(): NftGenesis;
    setFormatedDataPart(dataPart: nftProto.FormatedDataPart): void;
    getFormatedDataPart(): nftProto.FormatedDataPart;
    setFormatedDataPartFromLockingScript(script: bsv.Script): void;
    isFirstGenesis(): boolean;
    unlock({ txPreimage, sig, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, genesisSatoshis, nftScript, nftSatoshis, changeAddress, changeSatoshis, opReturnScript, }: {
        txPreimage: SigHashPreimage;
        sig: Sig;
        rabinMsg: Bytes;
        rabinPaddingArray: Bytes[];
        rabinSigArray: Int[];
        rabinPubKeyIndexArray: number[];
        rabinPubKeyVerifyArray: Int[];
        rabinPubKeyHashArray: Bytes;
        genesisSatoshis: number;
        nftScript: Bytes;
        nftSatoshis: number;
        changeAddress: Ripemd160;
        changeSatoshis: number;
        opReturnScript: Bytes;
    }): FunctionCall;
}
export declare class NftGenesisFactory {
    static lockingScriptSize: number;
    static getLockingScriptSize(): number;
    static createContract(issuerPubKey: bsv.PublicKey): NftGenesis;
    static getDummyInstance(): NftGenesis;
    static calLockingScriptSize(): number;
    static calUnlockingScriptSize(opreturnData: any): number;
}
