"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftFactory = exports.Nft = void 0;
const BN = require("../../bn.js");
const bsv = require("../../bsv");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const protoheader_1 = require("../../common/protoheader");
const TokenUtil = require("../../common/tokenUtil");
const utils_1 = require("../../common/utils");
const scryptlib_1 = require("../../scryptlib");
const nftProto = require("../contract-proto/nft.proto");
const nft_proto_1 = require("../contract-proto/nft.proto");
const contractUtil_1 = require("../contractUtil");
const nftSell_1 = require("./nftSell");
const nftUnlockContractCheck_1 = require("./nftUnlockContractCheck");
var NFT_CODE_VERSION;
(function (NFT_CODE_VERSION) {
    NFT_CODE_VERSION[NFT_CODE_VERSION["V1"] = 0] = "V1";
    NFT_CODE_VERSION[NFT_CODE_VERSION["V2"] = 1] = "V2";
})(NFT_CODE_VERSION || (NFT_CODE_VERSION = {}));
class Nft extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let desc = constuctParams.codeVersion == NFT_CODE_VERSION.V1
            ? require("../contract-desc/nft_desc.json")
            : require("../contract-desc/nft_v2_desc.json");
        let ClassObj = (0, scryptlib_1.buildContractClass)(desc);
        let contract = new ClassObj(constuctParams.unlockContractCodeHashArray);
        super(contract);
        this.constuctParams = constuctParams;
    }
    clone() {
        let contract = new Nft(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        this._formatedDataPart.genesisFlag = nftProto.GENESIS_FLAG.FALSE;
        this._formatedDataPart.protoVersion = nftProto.PROTO_VERSION;
        this._formatedDataPart.protoType = protoheader_1.PROTO_TYPE.NFT;
        super.setDataPart((0, scryptlib_1.toHex)(nftProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    unlock({ txPreimage, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, prevNftAddress, genesisScript, senderPubKey, senderSig, receiverAddress, nftOutputSatoshis, opReturnScript, changeAddress, changeSatoshis, checkInputIndex, checkScriptTx, checkScriptTxOutIndex, lockContractInputIndex, lockContractTx, lockContractTxOutIndex, operation, }) {
        if (!genesisScript) {
            genesisScript = new scryptlib_1.Bytes("");
        }
        if (operation != nft_proto_1.NFT_OP_TYPE.TRANSFER) {
            senderPubKey = new scryptlib_1.PubKey("00");
            senderSig = new scryptlib_1.Sig("00");
            receiverAddress = new scryptlib_1.Bytes("");
            nftOutputSatoshis = new scryptlib_1.Int(0);
            opReturnScript = new scryptlib_1.Bytes("");
            changeAddress = new scryptlib_1.Ripemd160("00");
            changeSatoshis = new scryptlib_1.Int(0);
        }
        if (operation != nft_proto_1.NFT_OP_TYPE.UNLOCK_FROM_CONTRACT) {
            checkInputIndex = 0;
            checkScriptTx = new scryptlib_1.Bytes("");
            checkScriptTxOutIndex = 0;
            lockContractInputIndex = 0;
            lockContractTx = new scryptlib_1.Bytes("");
            lockContractTxOutIndex = 0;
        }
        if (this.constuctParams.codeVersion == NFT_CODE_VERSION.V1) {
            return this._contract.unlock(txPreimage, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, prevNftAddress, genesisScript, senderPubKey, senderSig, receiverAddress, nftOutputSatoshis, opReturnScript, changeAddress, changeSatoshis, checkInputIndex, checkScriptTx, checkScriptTxOutIndex, lockContractInputIndex, lockContractTx, lockContractTxOutIndex, operation);
        }
        else {
            return this._contract.unlock(txPreimage, prevouts, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, prevNftAddress, genesisScript, senderPubKey, senderSig, receiverAddress, nftOutputSatoshis, opReturnScript, changeAddress, changeSatoshis, checkInputIndex, checkScriptTx, lockContractInputIndex, lockContractTx, operation);
        }
    }
}
exports.Nft = Nft;
class NftFactory {
    static getLockingScriptSize() {
        return this.lockingScriptSize;
    }
    static createContractV1(unlockContractCodeHashArray) {
        return new Nft({
            unlockContractCodeHashArray,
            codeVersion: NFT_CODE_VERSION.V1,
        });
    }
    static createContractV2(unlockContractCodeHashArray) {
        return new Nft({
            unlockContractCodeHashArray,
            codeVersion: NFT_CODE_VERSION.V2,
        });
    }
    static createContract(unlockContractCodeHashArray, codehash) {
        if (codehash == "0d0fc08db6e27dc0263b594d6b203f55fb5282e2") {
            return this.createContractV1(unlockContractCodeHashArray);
        }
        return this.createContractV2(unlockContractCodeHashArray);
    }
    static getDummyInstance() {
        let contract = this.createContract(contractUtil_1.ContractUtil.unlockContractCodeHashArray);
        contract.setFormatedDataPart({});
        return contract;
    }
    static calLockingScriptSize() {
        let contract = this.getDummyInstance();
        return contract.lockingScript.toBuffer().length;
    }
    static calUnlockingScriptSize(bsvInputLen, genesisScript, opreturnData, operation) {
        let opreturnScriptHex = "";
        if (opreturnData) {
            let script = bsv.Script.buildSafeDataOut(opreturnData);
            opreturnScriptHex = script.toHex();
        }
        let contract = this.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const sig = Buffer.from(utils_1.PLACE_HOLDER_SIG, "hex");
        const rabinMsg = new scryptlib_1.Bytes(dummy_1.dummyPayload);
        const rabinPaddingArray = [];
        const rabinSigArray = [];
        const rabinPubKeyIndexArray = [];
        const rabinPubKeyArray = [];
        for (let i = 0; i < nft_proto_1.SIGNER_VERIFY_NUM; i++) {
            rabinPaddingArray.push(new scryptlib_1.Bytes(dummy_1.dummyPadding));
            rabinSigArray.push(new scryptlib_1.Int(BN.fromString(dummy_1.dummySigBE, 16).toString(10)));
            rabinPubKeyIndexArray.push(i);
            rabinPubKeyArray.push(new scryptlib_1.Int(dummy_1.dummyRabinPubKey.toString(10)));
        }
        const nftInputIndex = 0;
        let prevouts = Buffer.alloc(0);
        const indexBuf = TokenUtil.getUInt32Buf(0);
        const txidBuf = TokenUtil.getTxIdBuf(dummy_1.dummyTxId);
        for (let i = 0; i < 1 + bsvInputLen; i++) {
            prevouts = Buffer.concat([prevouts, txidBuf, indexBuf]);
        }
        let unlockCheckContact = nftUnlockContractCheck_1.NftUnlockContractCheckFactory.getDummyInstance(nftUnlockContractCheck_1.NFT_UNLOCK_CONTRACT_TYPE.OUT_6);
        let checkScriptTx = new bsv.Transaction(dummy_1.dummyTx.serialize(true));
        checkScriptTx.addOutput(new bsv.Transaction.Output({
            script: unlockCheckContact.lockingScript,
            satoshis: 10000,
        }));
        let sellContract = nftSell_1.NftSellFactory.getDummyInstance();
        let sellTx = new bsv.Transaction(dummy_1.dummyTx.serialize(true));
        sellTx.addOutput(new bsv.Transaction.Output({
            script: sellContract.lockingScript,
            satoshis: 10000,
        }));
        let changeSatoshis = 0;
        let unlockedContract = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            prevouts: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(prevouts)),
            rabinMsg,
            rabinPaddingArray,
            rabinSigArray,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray: rabinPubKeyArray,
            rabinPubKeyHashArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyRabinPubKeyHashArray)),
            prevNftAddress: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            genesisScript,
            senderPubKey: new scryptlib_1.PubKey((0, scryptlib_1.toHex)(dummy_1.dummyPk)),
            senderSig: new scryptlib_1.Sig((0, scryptlib_1.toHex)(sig)),
            receiverAddress: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            nftOutputSatoshis: new scryptlib_1.Int(0),
            opReturnScript: new scryptlib_1.Bytes(opreturnScriptHex),
            changeAddress: new scryptlib_1.Ripemd160((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            changeSatoshis: new scryptlib_1.Int(changeSatoshis),
            checkInputIndex: 0,
            checkScriptTx: new scryptlib_1.Bytes(checkScriptTx.serialize(true)),
            checkScriptTxOutIndex: 0,
            lockContractInputIndex: 0,
            lockContractTx: new scryptlib_1.Bytes(sellTx.serialize(true)),
            lockContractTxOutIndex: 0,
            operation,
        });
        return unlockedContract.toScript().toBuffer().length;
    }
}
exports.NftFactory = NftFactory;
