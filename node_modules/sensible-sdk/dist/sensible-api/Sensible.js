"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sensible = void 0;
const error_1 = require("../common/error");
const net_1 = require("../net");
const index_1 = require("./index");
class Sensible {
    constructor(apiTarget, apiNet, serverBase) {
        if (apiTarget == index_1.API_TARGET.SENSIBLE) {
            if (apiNet == index_1.API_NET.MAIN) {
                this.serverBase = "https://api.sensiblequery.com";
            }
            else {
                this.serverBase = "https://api.sensiblequery.com/test";
            }
        }
        else if (apiTarget == index_1.API_TARGET.SHOW) {
            if (apiNet == index_1.API_NET.MAIN) {
                this.serverBase = "https://sensiblequery.show.sv";
            }
            else {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, "show only support mainnet");
            }
        }
        if (serverBase) {
            this.serverBase = serverBase;
        }
    }
    authorize(options) { }
    /**
     * @param {string} address
     */
    getUnspents(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/address/${address}/utxo?size=100`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            let ret = data.map((v) => ({
                txId: v.txid,
                outputIndex: v.vout,
                satoshis: v.satoshi,
                address: address,
            }));
            return ret;
        });
    }
    /**
     * @param {string} hex
     */
    broadcast(txHex, apiTarget = "sensible") {
        return __awaiter(this, void 0, void 0, function* () {
            if (apiTarget == "metasv") {
                let _res = yield net_1.Net.httpPost("https://apiv2.metasv.com/tx/broadcast", {
                    hex: txHex,
                });
                return _res.txid;
            }
            else {
                let url = `${this.serverBase}/pushtx`;
                let _res = yield net_1.Net.httpPost(url, {
                    txHex,
                });
                const { code, data, msg } = _res;
                if (code != 0) {
                    throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
                }
                return data;
            }
        });
    }
    /**
     * @param {string} txid
     */
    getRawTxData(txid) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/rawtx/${txid}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data) {
                console.log("getRawfailed", url);
            }
            return data;
        });
    }
    /**
     * 通过FT合约CodeHash+溯源genesis获取某地址的utxo列表
     */
    getFungibleTokenUnspents(codehash, genesis, address, size = 20) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/ft/utxo/${codehash}/${genesis}/${address}?size=${size}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return [];
            let ret = data.map((v) => ({
                txId: v.txid,
                outputIndex: v.vout,
                tokenAddress: address,
                tokenAmount: v.tokenAmount,
            }));
            return ret;
        });
    }
    /**
     * 查询某人持有的某FT的余额
     */
    getFungibleTokenBalance(codehash, genesis, address) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/ft/balance/${codehash}/${genesis}/${address}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            let ret = {
                balance: data.balance.toString(),
                pendingBalance: data.pendingBalance.toString(),
                utxoCount: data.utxoCount,
                decimal: data.decimal,
            };
            return ret;
        });
    }
    /**
     * 通过NFT合约CodeHash+溯源genesis获取某地址的utxo列表
     */
    getNonFungibleTokenUnspents(codehash, genesis, address, cursor = 0, size = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/utxo/${codehash}/${genesis}/${address}?cursor=${cursor}&size=${size}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return [];
            let ret = data.map((v) => ({
                txId: v.txid,
                outputIndex: v.vout,
                tokenAddress: address,
                tokenIndex: v.tokenIndex,
                metaTxId: v.metaTxId,
                metaOutputIndex: v.metaOutputIndex,
            }));
            return ret;
        });
    }
    /**
     * 查询某人持有的某FT的UTXO
     */
    getNonFungibleTokenUnspentDetail(codehash, genesis, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/utxo-detail/${codehash}/${genesis}/${tokenIndex}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return null;
            let ret = [data].map((v) => ({
                txId: v.txid,
                outputIndex: v.vout,
                tokenAddress: v.address,
                tokenIndex: v.tokenIndex,
                metaTxId: v.metaTxId,
                metaOutputIndex: v.metaOutputIndex,
            }))[0];
            return ret;
        });
    }
    /**
     * 查询某人持有的FT Token列表。获得每个token的余额
     */
    getFungibleTokenSummary(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/ft/summary/${address}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            let ret = [];
            data.forEach((v) => {
                ret.push({
                    codehash: v.codehash,
                    genesis: v.genesis,
                    sensibleId: v.sensibleId,
                    pendingBalance: v.pendingBalance.toString(),
                    balance: v.balance.toString(),
                    symbol: v.symbol,
                    decimal: v.decimal,
                });
            });
            return ret;
        });
    }
    /**
     * 查询某人持有的所有NFT Token列表。获得持有的nft数量计数
     * @param {String} address
     * @returns
     */
    getNonFungibleTokenSummary(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/summary/${address}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            let ret = [];
            if (data) {
                data.forEach((v) => {
                    ret.push({
                        codehash: v.codehash,
                        genesis: v.genesis,
                        sensibleId: v.sensibleId,
                        count: v.count,
                        pendingCount: v.pendingCount,
                        metaTxId: v.metaTxId,
                        metaOutputIndex: v.metaOutputIndex,
                        supply: v.supply,
                    });
                });
            }
            return ret;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/address/${address}/balance`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            return {
                balance: data.satoshi,
                pendingBalance: data.pendingSatoshi,
            };
        });
    }
    getNftSellUtxo(codehash, genesis, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/sell/utxo-detail/${codehash}/${genesis}/${tokenIndex}?isReadyOnly=true`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return null;
            let ret = data
                .filter((v) => v.isReady == true)
                .map((v) => ({
                codehash,
                genesis,
                tokenIndex,
                txId: v.txid,
                outputIndex: v.vout,
                sellerAddress: v.address,
                satoshisPrice: v.price,
            }))[0];
            return ret;
        });
    }
    getNftSellList(codehash, genesis, cursor = 0, size = 20) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/sell/utxo/${codehash}/${genesis}?cursor=${cursor}&size=${size}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return null;
            let ret = data.map((v) => ({
                codehash,
                genesis,
                tokenIndex: v.tokenIndex,
                txId: v.txid,
                outputIndex: v.vout,
                sellerAddress: v.address,
                satoshisPrice: v.price,
            }));
            return ret;
        });
    }
    getNftSellListByAddress(address, cursor = 0, size = 20) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/nft/sell/utxo-by-address/${address}?cursor=${cursor}&size=${size}`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                throw new error_1.CodeError(error_1.ErrCode.EC_SENSIBLE_API_ERROR, `request api failed. [url]:${url} [msg]:${msg}`);
            }
            if (!data)
                return null;
            let ret = data.map((v) => ({
                codehash: v.codehash,
                genesis: v.genesis,
                tokenIndex: v.tokenIndex,
                txId: v.txid,
                outputIndex: v.vout,
                sellerAddress: v.address,
                satoshisPrice: v.price,
            }));
            return ret;
        });
    }
    getOutpointSpent(txId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.serverBase}/tx/${txId}/out/${index}/spent`;
            let _res = yield net_1.Net.httpGet(url, {});
            const { code, data, msg } = _res;
            if (code != 0) {
                return null;
            }
            if (!data)
                return null;
            return {
                spentTxId: data.txid,
                spentInputIndex: data.idx,
            };
        });
    }
}
exports.Sensible = Sensible;
