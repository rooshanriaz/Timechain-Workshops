"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUnlockContractCheckFactory = exports.TokenUnlockContractCheck = exports.TOKEN_UNLOCK_TYPE = void 0;
const ContractAdapter_1 = require("../../common/ContractAdapter");
const scryptlib_1 = require("../../scryptlib");
const proto = require("../contract-proto/tokenUnlockContractCheck.proto");
var TOKEN_UNLOCK_TYPE;
(function (TOKEN_UNLOCK_TYPE) {
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["IN_2_OUT_5"] = 1] = "IN_2_OUT_5";
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["IN_4_OUT_8"] = 2] = "IN_4_OUT_8";
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["IN_8_OUT_12"] = 3] = "IN_8_OUT_12";
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["IN_3_OUT_100"] = 4] = "IN_3_OUT_100";
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["IN_20_OUT_5"] = 5] = "IN_20_OUT_5";
    TOKEN_UNLOCK_TYPE[TOKEN_UNLOCK_TYPE["UNSUPPORT"] = 6] = "UNSUPPORT";
})(TOKEN_UNLOCK_TYPE = exports.TOKEN_UNLOCK_TYPE || (exports.TOKEN_UNLOCK_TYPE = {}));
class TokenUnlockContractCheck extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let desc;
        switch (constuctParams.unlockType) {
            case TOKEN_UNLOCK_TYPE.IN_2_OUT_5:
                desc = require("../contract-desc/tokenUnlockContractCheck_desc.json");
                break;
            case TOKEN_UNLOCK_TYPE.IN_4_OUT_8:
                desc = require("../contract-desc/tokenUnlockContractCheck_4To8_desc.json");
                break;
            case TOKEN_UNLOCK_TYPE.IN_8_OUT_12:
                desc = require("../contract-desc/tokenUnlockContractCheck_8To12_desc.json");
                break;
            case TOKEN_UNLOCK_TYPE.IN_3_OUT_100:
                desc = require("../contract-desc/tokenUnlockContractCheck_3To100_desc.json");
                break;
            case TOKEN_UNLOCK_TYPE.IN_20_OUT_5:
                desc = require("../contract-desc/tokenUnlockContractCheck_20To5_desc.json");
                break;
            default:
                throw "invalid unlockType";
        }
        let ClassObj = (0, scryptlib_1.buildContractClass)(desc);
        let contract = new ClassObj();
        super(contract);
        this.constuctParams = constuctParams;
        this._formatedDataPart = {};
    }
    clone() {
        let contract = new TokenUnlockContractCheck(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        super.setDataPart((0, scryptlib_1.toHex)(proto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    unlock({ txPreimage, tokenScript, prevouts, rabinMsgArray, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, inputTokenAddressArray, inputTokenAmountArray, nOutputs, tokenOutputIndexArray, tokenOutputSatoshiArray, otherOutputArray, }) {
        return this._contract.unlock(txPreimage, tokenScript, prevouts, rabinMsgArray, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, inputTokenAddressArray, inputTokenAmountArray, nOutputs, tokenOutputIndexArray, tokenOutputSatoshiArray, otherOutputArray);
    }
}
exports.TokenUnlockContractCheck = TokenUnlockContractCheck;
class TokenUnlockContractCheckFactory {
    static getOptimumType(inCount, outCount) {
        if (inCount <= 2 && outCount <= 5) {
            return TOKEN_UNLOCK_TYPE.IN_2_OUT_5;
        }
        else if (inCount <= 4 && outCount <= 8) {
            return TOKEN_UNLOCK_TYPE.IN_4_OUT_8;
        }
        else if (inCount <= 8 && outCount <= 12) {
            return TOKEN_UNLOCK_TYPE.IN_8_OUT_12;
        }
        else if (inCount <= 20 && outCount <= 5) {
            return TOKEN_UNLOCK_TYPE.IN_20_OUT_5;
        }
        else if (inCount <= 3 && outCount <= 100) {
            return TOKEN_UNLOCK_TYPE.IN_3_OUT_100;
        }
        else {
            return TOKEN_UNLOCK_TYPE.UNSUPPORT;
        }
    }
    static createContract(unlockType) {
        return new TokenUnlockContractCheck({ unlockType });
    }
}
exports.TokenUnlockContractCheckFactory = TokenUnlockContractCheckFactory;
