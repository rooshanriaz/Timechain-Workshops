"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenGenesisFactory = exports.TokenGenesis = void 0;
const BN = require("../../bn.js");
const bsv = require("../../bsv");
const ContractAdapter_1 = require("../../common/ContractAdapter");
const dummy_1 = require("../../common/dummy");
const protoheader_1 = require("../../common/protoheader");
const utils_1 = require("../../common/utils");
const scryptlib_1 = require("../../scryptlib");
const ftProto = require("../contract-proto/token.proto");
const token_1 = require("./token");
const genesisTokenIDTxid = "0000000000000000000000000000000000000000000000000000000000000000";
class TokenGenesis extends ContractAdapter_1.ContractAdapter {
    constructor(constuctParams) {
        let desc = require("../contract-desc/tokenGenesis_desc.json");
        let ClassObj = (0, scryptlib_1.buildContractClass)(desc);
        let contract = new ClassObj(new scryptlib_1.PubKey((0, scryptlib_1.toHex)(constuctParams.pubKey)));
        super(contract);
        this.constuctParams = constuctParams;
        this._formatedDataPart = {};
    }
    clone() {
        let contract = new TokenGenesis(this.constuctParams);
        contract.setFormatedDataPart(this.getFormatedDataPart());
        return contract;
    }
    setFormatedDataPart(dataPart) {
        this._formatedDataPart = Object.assign({}, this._formatedDataPart, dataPart);
        this._formatedDataPart.genesisHash = "";
        this._formatedDataPart.genesisFlag = ftProto.GENESIS_FLAG.TRUE;
        this._formatedDataPart.protoVersion = ftProto.PROTO_VERSION;
        this._formatedDataPart.protoType = protoheader_1.PROTO_TYPE.FT;
        super.setDataPart((0, scryptlib_1.toHex)(ftProto.newDataPart(this._formatedDataPart)));
    }
    getFormatedDataPart() {
        return this._formatedDataPart;
    }
    setFormatedDataPartFromLockingScript(script) {
        let dataPart = ftProto.parseDataPart(script.toBuffer());
        this.setFormatedDataPart(dataPart);
    }
    isFirstGenesis() {
        return this.getFormatedDataPart().sensibleID.txid == genesisTokenIDTxid;
    }
    unlock({ txPreimage, sig, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, genesisSatoshis, tokenScript, tokenSatoshis, changeAddress, changeSatoshis, opReturnScript, }) {
        return this._contract.unlock(txPreimage, sig, rabinMsg, rabinPaddingArray, rabinSigArray, rabinPubKeyIndexArray, rabinPubKeyVerifyArray, rabinPubKeyHashArray, genesisSatoshis, tokenScript, tokenSatoshis, changeAddress, changeSatoshis, opReturnScript);
    }
}
exports.TokenGenesis = TokenGenesis;
class TokenGenesisFactory {
    static getLockingScriptSize() {
        return this.lockingScriptSize;
    }
    /**
     * create genesis contract
     * @param {Object} issuerPubKey issuer public key used to unlocking genesis contract
     * @param {string} tokenName the token name
     * @param {string} tokenSymbol the token symbol
     * @param {number} decimalNum the token amount decimal number
     * @returns
     */
    static createContract(issuerPubKey) {
        return new TokenGenesis({ pubKey: issuerPubKey });
    }
    static getDummyInstance() {
        let contract = this.createContract(dummy_1.dummyPk);
        contract.setFormatedDataPart({});
        return contract;
    }
    static calLockingScriptSize() {
        let contract = this.getDummyInstance();
        let size = contract.lockingScript.toBuffer().length;
        return size;
    }
    static calUnlockingScriptSize(opreturnData) {
        let opreturnScriptHex = "";
        if (opreturnData) {
            let script = bsv.Script.buildSafeDataOut(opreturnData);
            opreturnScriptHex = script.toHex();
        }
        let contract = this.getDummyInstance();
        let tokenContract = token_1.TokenFactory.getDummyInstance();
        const preimage = (0, scryptlib_1.getPreimage)(dummy_1.dummyTx, contract.lockingScript.toASM(), 1);
        const sig = Buffer.from(utils_1.PLACE_HOLDER_SIG, "hex");
        const rabinMsg = dummy_1.dummyPayload;
        const rabinPaddingArray = [];
        const rabinSigArray = [];
        const rabinPubKeyIndexArray = [];
        const rabinPubKeyVerifyArray = [];
        for (let i = 0; i < ftProto.SIGNER_VERIFY_NUM; i++) {
            rabinPaddingArray.push(new scryptlib_1.Bytes(dummy_1.dummyPadding));
            rabinSigArray.push(new scryptlib_1.Int(BN.fromString(dummy_1.dummySigBE, 16).toString(10)));
            rabinPubKeyIndexArray.push(i);
            rabinPubKeyVerifyArray.push(new scryptlib_1.Int(dummy_1.dummyRabinPubKey.toString(10)));
        }
        let unlockResult = contract.unlock({
            txPreimage: new scryptlib_1.SigHashPreimage((0, scryptlib_1.toHex)(preimage)),
            sig: new scryptlib_1.Sig((0, scryptlib_1.toHex)(sig)),
            rabinMsg: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(rabinMsg)),
            rabinPaddingArray,
            rabinSigArray,
            rabinPubKeyIndexArray,
            rabinPubKeyVerifyArray,
            rabinPubKeyHashArray: new scryptlib_1.Bytes((0, scryptlib_1.toHex)(dummy_1.dummyRabinPubKeyHashArray)),
            genesisSatoshis: 1000,
            tokenScript: new scryptlib_1.Bytes(tokenContract.lockingScript.toHex()),
            tokenSatoshis: 1000,
            changeAddress: new scryptlib_1.Ripemd160((0, scryptlib_1.toHex)(dummy_1.dummyAddress.hashBuffer)),
            changeSatoshis: 1000,
            opReturnScript: new scryptlib_1.Bytes(opreturnScriptHex),
        });
        return unlockResult.toScript().toBuffer().length;
    }
}
exports.TokenGenesisFactory = TokenGenesisFactory;
