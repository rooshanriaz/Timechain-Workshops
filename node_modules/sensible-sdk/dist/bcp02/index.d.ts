/// <reference types="node" />
import { Bytes, Int } from "scryptlib";
import * as BN from "../bn.js";
import * as bsv from "../bsv";
import { SatotxSigner, SignerConfig } from "../common/SatotxSigner";
import * as Utils from "../common/utils";
import { SigHashInfo, SigInfo } from "../common/utils";
import { API_NET, API_TARGET, FungibleTokenUnspent, SensibleApiBase } from "../sensible-api";
import * as ftProto from "./contract-proto/token.proto";
export declare const sighashType: number;
export declare const defaultSignerConfigs: SignerConfig[];
declare type ParamUtxo = {
    txId: string;
    outputIndex: number;
    satoshis: number;
    wif?: string;
    address?: string | bsv.Address;
};
declare type ParamFtUtxo = {
    txId: string;
    outputIndex: number;
    tokenAddress: string;
    tokenAmount: string;
    wif?: string;
};
declare type TokenReceiver = {
    address: string;
    amount: string;
};
declare type MockData = {
    sensibleApi: SensibleApiBase;
    satotxSigners: SatotxSigner[];
};
export declare type Utxo = {
    txId: string;
    outputIndex: number;
    satoshis: number;
    address: bsv.Address;
};
export declare type FtUtxo = {
    txId: string;
    outputIndex: number;
    satoshis?: number;
    lockingScript?: bsv.Script;
    tokenAddress?: bsv.Address;
    tokenAmount?: BN;
    satotxInfo?: {
        txId?: string;
        outputIndex?: number;
        txHex?: string;
        preTxId?: string;
        preOutputIndex?: number;
        preTxHex?: string;
    };
    preTokenAddress?: bsv.Address;
    preTokenAmount?: BN;
    preLockingScript?: bsv.Script;
    publicKey?: bsv.PublicKey;
};
/**
Sensible Fungible Token
 */
export declare class SensibleFT {
    private signers;
    private feeb;
    private network;
    private purse;
    sensibleApi: SensibleApiBase;
    private zeroAddress;
    private debug;
    private transferPart2?;
    private signerSelecteds;
    private dustCalculator?;
    rabinPubKeyArray: Int[];
    rabinPubKeyHashArray: Bytes;
    rabinPubKeyHashArrayHash: Buffer;
    transferCheckCodeHashArray: Bytes[];
    unlockContractCodeHashArray: Bytes[];
    /**
     *
     * @param signers
     * @param signerSelecteds (Optional) the indexs of the signers which is decided to verify
     * @param feeb (Optional) the fee rate. default is 0.5
     * @param network (Optional) mainnet/testnet default is mainnet
     * @param purse (Optional) the private key to offer transacions fee. If not provided, bsv utoxs must be provided in genesis/issue/transfer.
     * @param debug (Optional) specify if verify the tx when genesis/issue/transfer, default is false
     * @param apiTarget (Optional) SENSIBLE/METASV, default is SENSIBLE.
     * @param dustLimitFactor (Optional) specify the output dust rate, default is 0.25 .If the value is equal to 0, the final dust will be at least 1.
     * @param dustAmount (Optional) specify the output dust.
     */
    constructor({ signers, signerSelecteds, feeb, network, purse, debug, apiTarget, apiUrl, mockData, dustLimitFactor, dustAmount, }: {
        signers?: SignerConfig[];
        signerSelecteds?: number[];
        feeb?: number;
        network?: API_NET;
        purse?: string;
        debug?: boolean;
        apiTarget?: API_TARGET;
        apiUrl?: string;
        mockData?: MockData;
        dustLimitFactor?: number;
        dustAmount?: number;
    });
    /**
     * Pick the signer with the best connectivity
     * @param signerConfigs
     * @returns
     */
    static selectSigners(signerConfigs?: SignerConfig[]): Promise<{
        signers: SignerConfig[];
        signerSelecteds: number[];
    }>;
    /**
     * set dust. DustAmount has a higher priority than dustLimitFactor
     * @param dustLimitFactor specify the output dust rate, default is 0.25 .If the value is equal to 0, the final dust will be at least 1.
     * @param dustAmount specify the output dust
     */
    setDustThreshold({ dustLimitFactor, dustAmount, }: {
        dustLimitFactor?: number;
        dustAmount?: number;
    }): void;
    private getDustThreshold;
    private _pretreatUtxos;
    private _pretreatFtUtxos;
    /**
     * Create a transaction for genesis
     * @param tokenName token name, limited to 20 bytes
     * @param tokenSymbol the token symbol, limited to 10 bytes
     * @param decimalNum the decimal number, range 0-255
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @param genesisWif the private key of the token genesiser
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    genesis({ tokenName, tokenSymbol, decimalNum, utxos, changeAddress, opreturnData, genesisWif, noBroadcast, }: {
        tokenName: string;
        tokenSymbol: string;
        decimalNum: number;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        opreturnData?: any;
        genesisWif: string | bsv.PrivateKey;
        noBroadcast?: boolean;
    }): Promise<{
        txHex: string;
        txid: string;
        genesis: string;
        codehash: string;
        tx: bsv.Transaction;
        sensibleId: string;
    }>;
    /**
     * create an unsigned transaction for genesis
     * @param tokenName token name, limited to 20 bytes
     * @param tokenSymbol the token symbol, limited to 10 bytes
     * @param decimalNum the decimal number, range 0-255
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @param genesisPublicKey the public key of the token genesiser
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     * @returns
     */
    unsignGenesis({ tokenName, tokenSymbol, decimalNum, utxos, changeAddress, opreturnData, genesisPublicKey, }: {
        tokenName: string;
        tokenSymbol: string;
        decimalNum: number;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        opreturnData?: any;
        genesisPublicKey: string | bsv.PublicKey;
    }): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    private _genesis;
    /**
     * Issue tokens.
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param sensibleId the sensibleId of token.
     * @param genesisWif the private key of the token genesiser
     * @param receiverAddress the token receiver address
     * @param tokenAmount the token amount to issue
     * @param allowIncreaseIssues (Optional) if allow to increase issues.default is true
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    issue({ genesis, codehash, sensibleId, genesisWif, receiverAddress, tokenAmount, allowIncreaseIssues, utxos, changeAddress, opreturnData, noBroadcast, }: {
        genesis: string;
        codehash: string;
        sensibleId: string;
        genesisWif: string;
        receiverAddress: string | bsv.Address;
        tokenAmount: string | BN;
        allowIncreaseIssues: boolean;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        opreturnData?: any;
        noBroadcast?: boolean;
    }): Promise<{
        txHex: string;
        txid: string;
        tx: bsv.Transaction;
    }>;
    /**
     * Create the unsigned transaction for issue tokens,
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param genesisPublicKey the public key of the token genesiser
     * @param receiverAddress the token receiver address
     * @param tokenAmount the token amount to issue
     * @param allowIncreaseIssues (Optional) if allow to increase issues.default is true
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @returns
     */
    unsignIssue({ genesis, codehash, sensibleId, genesisPublicKey, receiverAddress, tokenAmount, allowIncreaseIssues, utxos, changeAddress, opreturnData, }: {
        genesis: string;
        codehash: string;
        sensibleId: string;
        genesisPublicKey: string | bsv.PublicKey;
        receiverAddress: string | bsv.Address;
        tokenAmount: string | BN;
        allowIncreaseIssues?: boolean;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        opreturnData?: any;
    }): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    private _getIssueUtxo;
    private _prepareIssueUtxo;
    private _issue;
    /**
     * After deciding which ftUxtos to use, perfect the information of FtUtxo
     * txHex,preTxId,preOutputIndex,preTxHex,preTokenAddress,preTokenAmount
     */
    private perfectFtUtxosInfo;
    /**
     * Transfer tokens
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param receivers token receivers.[{address:'xxx',amount:'1000'}]
     * @param senderWif the private key of the token sender,can be wif or other format
     * @param ftUtxos (Optional) specify token utxos
     * @param ftChangeAddress (Optional) specify ft changeAddress
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param middleChangeAddress (Optional) the middle bsv changeAddress
     * @param middlePrivateKey (Optional) the private key of the middle changeAddress
     * @param isMerge (Optional) do not use this param.Please use function Merge.
     * @param opreturnData (Optional) append an opReturn output
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
  
     * @returns
     */
    transfer({ codehash, genesis, receivers, senderWif, ftUtxos, ftChangeAddress, utxos, changeAddress, middleChangeAddress, middlePrivateKey, minUtxoSet, isMerge, opreturnData, noBroadcast, }: {
        codehash: string;
        genesis: string;
        receivers?: TokenReceiver[];
        senderWif?: string;
        ftUtxos?: ParamFtUtxo[];
        ftChangeAddress?: string | bsv.Address;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        middleChangeAddress?: string | bsv.Address;
        middlePrivateKey?: string | bsv.PrivateKey;
        minUtxoSet?: boolean;
        isMerge?: boolean;
        opreturnData?: any;
        noBroadcast?: boolean;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        routeCheckTx: bsv.Transaction;
        routeCheckTxHex: string;
    }>;
    /**
     * create the first part of unsigned transaction to transfer tokens.
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param receivers token receivers.[{address:'xxx',amount:'1000'}]
     * @param senderPublicKey the public key of the token sender
     * @param ftUtxos (Optional) specify token utxos
     * @param ftChangeAddress (Optional) specify ft changeAddress
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param middleChangeAddress (Optional) the middle bsv changeAddress
     * @param isMerge (Optional) specify if this is a merge
     * @param opreturnData (Optional) append an opReturn output
     * @returns
     */
    unsignPreTransfer({ codehash, genesis, receivers, senderPublicKey, ftUtxos, ftChangeAddress, utxos, changeAddress, isMerge, opreturnData, middleChangeAddress, minUtxoSet, }: {
        codehash: string;
        genesis: string;
        receivers?: TokenReceiver[];
        senderPublicKey?: string | bsv.PublicKey;
        ftUtxos?: ParamFtUtxo[];
        ftChangeAddress?: string | bsv.Address;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        isMerge?: boolean;
        opreturnData?: any;
        middleChangeAddress?: string | bsv.Address;
        minUtxoSet?: boolean;
    }): Promise<{
        routeCheckTx: bsv.Transaction;
        routeCheckSigHashList: SigHashInfo[];
        unsignTxRaw: string;
    }>;
    unsignTransfer(routeCheckTx: bsv.Transaction, unsignTxRaw: string): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    private _prepareTransferTokens;
    private _transfer;
    /**
     * Create a transaction for merging tokens, merging up to 20 utxo
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param ownerWif the private key of the token owner,can be wif or other format
     * @param utxos (Optional) specify bsv utxos which should be no more than 3
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @param noBroadcast (Optional) whether not to broadcast the transaction, the default is false
     * @returns
     */
    merge({ codehash, genesis, ownerWif, utxos, changeAddress, noBroadcast, opreturnData, }: {
        codehash: string;
        genesis: string;
        ownerWif: string;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        noBroadcast?: boolean;
        opreturnData?: any;
    }): Promise<{
        tx: bsv.Transaction;
        txHex: string;
        txid: string;
        routeCheckTx: bsv.Transaction;
        routeCheckTxHex: string;
    }>;
    /**
     * Create the first part of the unsigned transaction for merging tokens, merging up to 20 utxo
     * @param genesis the genesis of token.
     * @param codehash the codehash of token.
     * @param ownerPublicKey the public key of the token owner,can be string or other valid format
     * @param ftUtxos (Optional) specify token utxos
     * @param ftChangeAddress (Optional) specify token changeAddress
     * @param utxos (Optional) specify bsv utxos
     * @param changeAddress (Optional) specify bsv changeAddress
     * @param opreturnData (Optional) append an opReturn output
     * @returns
     */
    unsignPreMerge({ codehash, genesis, ownerPublicKey, ftUtxos, ftChangeAddress, utxos, changeAddress, opreturnData, }: {
        codehash: string;
        genesis: string;
        ownerPublicKey: string | bsv.PublicKey;
        ftUtxos?: ParamFtUtxo[];
        ftChangeAddress?: string | bsv.Address;
        utxos?: ParamUtxo[];
        changeAddress?: string | bsv.Address;
        opreturnData?: any;
    }): Promise<{
        routeCheckTx: bsv.Transaction;
        routeCheckSigHashList: Utils.SigHashInfo[];
        unsignTxRaw: string;
    }>;
    unsignMerge(routeCheckTx: bsv.Transaction, unsignTxRaw: string): Promise<{
        tx: bsv.Transaction;
        sigHashList: SigHashInfo[];
    }>;
    /**
     * Query token balance
     * @param codehash
     * @param genesis
     * @param address
     * @returns
     */
    getBalance({ codehash, genesis, address, }: {
        codehash: string;
        genesis: string;
        address: string;
    }): Promise<string>;
    /**
     * Query token balance detail
     * @param codehash
     * @param genesis
     * @param address
     * @returns
     */
    getBalanceDetail({ codehash, genesis, address, }: {
        codehash: string;
        genesis: string;
        address: string;
    }): Promise<{
        balance: string;
        pendingBalance: string;
        utxoCount: number;
        decimal: number;
    }>;
    /**
     * Query the Token list under this address. Get the balance of each token
     * @param address
     * @returns
     */
    getSummary(address: string): Promise<import("../sensible-api").FungibleTokenSummary[]>;
    /**
     * Estimate the cost of genesis
     * @param opreturnData
     * @param utxoMaxCount Maximum number of BSV UTXOs supported
     * @returns
     */
    getGenesisEstimateFee({ opreturnData, utxoMaxCount, }: {
        opreturnData?: any;
        utxoMaxCount?: number;
    }): Promise<number>;
    /**
     * Estimate the cost of issue
     * The minimum cost required in the case of 10 utxo inputs .
     * @param sensibleId
     * @param genesisPublicKey
     * @param opreturnData
     * @param utxoMaxCount Maximum number of BSV UTXOs supported
     * @returns
     */
    getIssueEstimateFee({ sensibleId, genesisPublicKey, opreturnData, allowIncreaseIssues, utxoMaxCount, }: {
        sensibleId: string;
        genesisPublicKey: string | bsv.PublicKey;
        opreturnData?: any;
        allowIncreaseIssues: boolean;
        utxoMaxCount?: number;
    }): Promise<number>;
    private _calIssueEstimateFee;
    /**
     * Estimate the cost of transfer
     */
    getTransferEstimateFee({ codehash, genesis, receivers, senderWif, senderPrivateKey, senderPublicKey, ftUtxos, ftChangeAddress, isMerge, opreturnData, utxoMaxCount, minUtxoSet, }: {
        codehash: string;
        genesis: string;
        receivers?: TokenReceiver[];
        senderWif?: string;
        senderPrivateKey?: string | bsv.PrivateKey;
        senderPublicKey?: string | bsv.PublicKey;
        ftUtxos?: ParamFtUtxo[];
        ftChangeAddress?: string | bsv.Address;
        isMerge?: boolean;
        opreturnData?: any;
        utxoMaxCount?: number;
        minUtxoSet?: boolean;
    }): Promise<number>;
    /**
     * Estimate the cost of merge
     */
    getMergeEstimateFee({ codehash, genesis, ownerWif, ownerPublicKey, ftUtxos, ftChangeAddress, opreturnData, utxoMaxCount, minUtxoSet, }: {
        codehash: string;
        genesis: string;
        ownerWif?: string;
        ownerPublicKey?: string | bsv.PublicKey;
        ftUtxos?: ParamFtUtxo[];
        ftChangeAddress?: string | bsv.Address;
        opreturnData?: any;
        utxoMaxCount?: number;
        minUtxoSet?: boolean;
    }): Promise<number>;
    /**
     * Update the signature of the transaction
     * @param tx
     * @param sigHashList
     * @param sigList
     */
    sign(tx: bsv.Transaction, sigHashList: SigHashInfo[], sigList: SigInfo[]): void;
    /**
     * Broadcast a transaction
     * @param txHex
     */
    broadcast(txHex: string): Promise<string>;
    private _calTransferEstimateFee;
    /**
     * Estimate the cost of transfer
     */
    getTransferEstimateFee2({ bsvInputLen, tokenInputLen, tokenOutputLen, opreturnData, }: {
        bsvInputLen: number;
        tokenInputLen: number;
        tokenOutputLen: number;
        opreturnData?: any;
    }): Promise<number>;
    /**
     * Print tx
     * @param tx
     */
    dumpTx(tx: bsv.Transaction): void;
    /**
     * Query token's utxos
     * @param codehash
     * @param genesis
     * @param address
     * @param count
     * @returns
     */
    getFtUtxos(codehash: string, genesis: string, address: string, count?: number): Promise<FungibleTokenUnspent[]>;
    /**
     * Check if codehash is supported
     * @param codehash
     * @returns
     */
    static isSupportedToken(codehash: string): boolean;
    /**
     * Check if codehash and sensibleID is supported
     * @param codehash
     * @param sensibleId
     * @returns
     */
    isSupportedToken(codehash: string, sensibleId: string): Promise<boolean>;
    /**
     * Get codehash and genesis from genesis tx.
     * @param genesisTx genesis tx
     * @param genesisOutputIndex (Optional) outputIndex - default value is 0.
     * @returns
     */
    getCodehashAndGensisByTx(genesisTx: bsv.Transaction, genesisOutputIndex?: number): {
        codehash: string;
        genesis: string;
        sensibleId: string;
    };
    private _checkTxFeeRate;
    /**
     * parse a output script to get Token info
     * @param scriptBuf
     * @param network
     * @returns
     */
    static parseTokenScript(scriptBuf: Buffer, network?: API_NET): {
        codehash: string;
        genesis: string;
        sensibleId: string;
        tokenName: string;
        tokenSymbol: string;
        genesisFlag: number;
        decimalNum: number;
        tokenAddress: string;
        tokenAmount: BN;
        genesisHash: string;
        rabinPubKeyHashArrayHash: string;
        sensibleID: ftProto.SensibleID;
        protoVersion: number;
        protoType: number;
    };
}
export {};
